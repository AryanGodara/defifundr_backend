// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"context"
	"sync"

	"github.com/demola234/defifundr/internal/core/domain"
	"github.com/demola234/defifundr/internal/core/ports"
	"github.com/google/uuid"
)

type FakeKYCRepository struct {
	CreateKYCStub        func(context.Context, domain.KYC) (*domain.KYC, error)
	createKYCMutex       sync.RWMutex
	createKYCArgsForCall []struct {
		arg1 context.Context
		arg2 domain.KYC
	}
	createKYCReturns struct {
		result1 *domain.KYC
		result2 error
	}
	createKYCReturnsOnCall map[int]struct {
		result1 *domain.KYC
		result2 error
	}
	GetKYCByUserIDStub        func(context.Context, uuid.UUID) (*domain.KYC, error)
	getKYCByUserIDMutex       sync.RWMutex
	getKYCByUserIDArgsForCall []struct {
		arg1 context.Context
		arg2 uuid.UUID
	}
	getKYCByUserIDReturns struct {
		result1 *domain.KYC
		result2 error
	}
	getKYCByUserIDReturnsOnCall map[int]struct {
		result1 *domain.KYC
		result2 error
	}
	UpdateKYCStub        func(context.Context, domain.KYC) (*domain.KYC, error)
	updateKYCMutex       sync.RWMutex
	updateKYCArgsForCall []struct {
		arg1 context.Context
		arg2 domain.KYC
	}
	updateKYCReturns struct {
		result1 *domain.KYC
		result2 error
	}
	updateKYCReturnsOnCall map[int]struct {
		result1 *domain.KYC
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeKYCRepository) CreateKYC(arg1 context.Context, arg2 domain.KYC) (*domain.KYC, error) {
	fake.createKYCMutex.Lock()
	ret, specificReturn := fake.createKYCReturnsOnCall[len(fake.createKYCArgsForCall)]
	fake.createKYCArgsForCall = append(fake.createKYCArgsForCall, struct {
		arg1 context.Context
		arg2 domain.KYC
	}{arg1, arg2})
	stub := fake.CreateKYCStub
	fakeReturns := fake.createKYCReturns
	fake.recordInvocation("CreateKYC", []interface{}{arg1, arg2})
	fake.createKYCMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKYCRepository) CreateKYCCallCount() int {
	fake.createKYCMutex.RLock()
	defer fake.createKYCMutex.RUnlock()
	return len(fake.createKYCArgsForCall)
}

func (fake *FakeKYCRepository) CreateKYCCalls(stub func(context.Context, domain.KYC) (*domain.KYC, error)) {
	fake.createKYCMutex.Lock()
	defer fake.createKYCMutex.Unlock()
	fake.CreateKYCStub = stub
}

func (fake *FakeKYCRepository) CreateKYCArgsForCall(i int) (context.Context, domain.KYC) {
	fake.createKYCMutex.RLock()
	defer fake.createKYCMutex.RUnlock()
	argsForCall := fake.createKYCArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeKYCRepository) CreateKYCReturns(result1 *domain.KYC, result2 error) {
	fake.createKYCMutex.Lock()
	defer fake.createKYCMutex.Unlock()
	fake.CreateKYCStub = nil
	fake.createKYCReturns = struct {
		result1 *domain.KYC
		result2 error
	}{result1, result2}
}

func (fake *FakeKYCRepository) CreateKYCReturnsOnCall(i int, result1 *domain.KYC, result2 error) {
	fake.createKYCMutex.Lock()
	defer fake.createKYCMutex.Unlock()
	fake.CreateKYCStub = nil
	if fake.createKYCReturnsOnCall == nil {
		fake.createKYCReturnsOnCall = make(map[int]struct {
			result1 *domain.KYC
			result2 error
		})
	}
	fake.createKYCReturnsOnCall[i] = struct {
		result1 *domain.KYC
		result2 error
	}{result1, result2}
}

func (fake *FakeKYCRepository) GetKYCByUserID(arg1 context.Context, arg2 uuid.UUID) (*domain.KYC, error) {
	fake.getKYCByUserIDMutex.Lock()
	ret, specificReturn := fake.getKYCByUserIDReturnsOnCall[len(fake.getKYCByUserIDArgsForCall)]
	fake.getKYCByUserIDArgsForCall = append(fake.getKYCByUserIDArgsForCall, struct {
		arg1 context.Context
		arg2 uuid.UUID
	}{arg1, arg2})
	stub := fake.GetKYCByUserIDStub
	fakeReturns := fake.getKYCByUserIDReturns
	fake.recordInvocation("GetKYCByUserID", []interface{}{arg1, arg2})
	fake.getKYCByUserIDMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKYCRepository) GetKYCByUserIDCallCount() int {
	fake.getKYCByUserIDMutex.RLock()
	defer fake.getKYCByUserIDMutex.RUnlock()
	return len(fake.getKYCByUserIDArgsForCall)
}

func (fake *FakeKYCRepository) GetKYCByUserIDCalls(stub func(context.Context, uuid.UUID) (*domain.KYC, error)) {
	fake.getKYCByUserIDMutex.Lock()
	defer fake.getKYCByUserIDMutex.Unlock()
	fake.GetKYCByUserIDStub = stub
}

func (fake *FakeKYCRepository) GetKYCByUserIDArgsForCall(i int) (context.Context, uuid.UUID) {
	fake.getKYCByUserIDMutex.RLock()
	defer fake.getKYCByUserIDMutex.RUnlock()
	argsForCall := fake.getKYCByUserIDArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeKYCRepository) GetKYCByUserIDReturns(result1 *domain.KYC, result2 error) {
	fake.getKYCByUserIDMutex.Lock()
	defer fake.getKYCByUserIDMutex.Unlock()
	fake.GetKYCByUserIDStub = nil
	fake.getKYCByUserIDReturns = struct {
		result1 *domain.KYC
		result2 error
	}{result1, result2}
}

func (fake *FakeKYCRepository) GetKYCByUserIDReturnsOnCall(i int, result1 *domain.KYC, result2 error) {
	fake.getKYCByUserIDMutex.Lock()
	defer fake.getKYCByUserIDMutex.Unlock()
	fake.GetKYCByUserIDStub = nil
	if fake.getKYCByUserIDReturnsOnCall == nil {
		fake.getKYCByUserIDReturnsOnCall = make(map[int]struct {
			result1 *domain.KYC
			result2 error
		})
	}
	fake.getKYCByUserIDReturnsOnCall[i] = struct {
		result1 *domain.KYC
		result2 error
	}{result1, result2}
}

func (fake *FakeKYCRepository) UpdateKYC(arg1 context.Context, arg2 domain.KYC) (*domain.KYC, error) {
	fake.updateKYCMutex.Lock()
	ret, specificReturn := fake.updateKYCReturnsOnCall[len(fake.updateKYCArgsForCall)]
	fake.updateKYCArgsForCall = append(fake.updateKYCArgsForCall, struct {
		arg1 context.Context
		arg2 domain.KYC
	}{arg1, arg2})
	stub := fake.UpdateKYCStub
	fakeReturns := fake.updateKYCReturns
	fake.recordInvocation("UpdateKYC", []interface{}{arg1, arg2})
	fake.updateKYCMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKYCRepository) UpdateKYCCallCount() int {
	fake.updateKYCMutex.RLock()
	defer fake.updateKYCMutex.RUnlock()
	return len(fake.updateKYCArgsForCall)
}

func (fake *FakeKYCRepository) UpdateKYCCalls(stub func(context.Context, domain.KYC) (*domain.KYC, error)) {
	fake.updateKYCMutex.Lock()
	defer fake.updateKYCMutex.Unlock()
	fake.UpdateKYCStub = stub
}

func (fake *FakeKYCRepository) UpdateKYCArgsForCall(i int) (context.Context, domain.KYC) {
	fake.updateKYCMutex.RLock()
	defer fake.updateKYCMutex.RUnlock()
	argsForCall := fake.updateKYCArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeKYCRepository) UpdateKYCReturns(result1 *domain.KYC, result2 error) {
	fake.updateKYCMutex.Lock()
	defer fake.updateKYCMutex.Unlock()
	fake.UpdateKYCStub = nil
	fake.updateKYCReturns = struct {
		result1 *domain.KYC
		result2 error
	}{result1, result2}
}

func (fake *FakeKYCRepository) UpdateKYCReturnsOnCall(i int, result1 *domain.KYC, result2 error) {
	fake.updateKYCMutex.Lock()
	defer fake.updateKYCMutex.Unlock()
	fake.UpdateKYCStub = nil
	if fake.updateKYCReturnsOnCall == nil {
		fake.updateKYCReturnsOnCall = make(map[int]struct {
			result1 *domain.KYC
			result2 error
		})
	}
	fake.updateKYCReturnsOnCall[i] = struct {
		result1 *domain.KYC
		result2 error
	}{result1, result2}
}

func (fake *FakeKYCRepository) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createKYCMutex.RLock()
	defer fake.createKYCMutex.RUnlock()
	fake.getKYCByUserIDMutex.RLock()
	defer fake.getKYCByUserIDMutex.RUnlock()
	fake.updateKYCMutex.RLock()
	defer fake.updateKYCMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeKYCRepository) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ ports.KYCRepository = new(FakeKYCRepository)
