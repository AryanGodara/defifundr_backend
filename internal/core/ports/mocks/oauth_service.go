// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"context"
	"sync"

	"github.com/demola234/defifundr/internal/core/ports"
)

type FakeOAuthService struct {
	GetUserInfoStub        func(context.Context, string) (map[string]interface{}, error)
	getUserInfoMutex       sync.RWMutex
	getUserInfoArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	getUserInfoReturns struct {
		result1 map[string]interface{}
		result2 error
	}
	getUserInfoReturnsOnCall map[int]struct {
		result1 map[string]interface{}
		result2 error
	}
	GetUserInfoByEmailStub        func(context.Context, string) (map[string]interface{}, error)
	getUserInfoByEmailMutex       sync.RWMutex
	getUserInfoByEmailArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	getUserInfoByEmailReturns struct {
		result1 map[string]interface{}
		result2 error
	}
	getUserInfoByEmailReturnsOnCall map[int]struct {
		result1 map[string]interface{}
		result2 error
	}
	ValidateWebAuthTokenStub        func(context.Context, string) (map[string]interface{}, error)
	validateWebAuthTokenMutex       sync.RWMutex
	validateWebAuthTokenArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	validateWebAuthTokenReturns struct {
		result1 map[string]interface{}
		result2 error
	}
	validateWebAuthTokenReturnsOnCall map[int]struct {
		result1 map[string]interface{}
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeOAuthService) GetUserInfo(arg1 context.Context, arg2 string) (map[string]interface{}, error) {
	fake.getUserInfoMutex.Lock()
	ret, specificReturn := fake.getUserInfoReturnsOnCall[len(fake.getUserInfoArgsForCall)]
	fake.getUserInfoArgsForCall = append(fake.getUserInfoArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.GetUserInfoStub
	fakeReturns := fake.getUserInfoReturns
	fake.recordInvocation("GetUserInfo", []interface{}{arg1, arg2})
	fake.getUserInfoMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeOAuthService) GetUserInfoCallCount() int {
	fake.getUserInfoMutex.RLock()
	defer fake.getUserInfoMutex.RUnlock()
	return len(fake.getUserInfoArgsForCall)
}

func (fake *FakeOAuthService) GetUserInfoCalls(stub func(context.Context, string) (map[string]interface{}, error)) {
	fake.getUserInfoMutex.Lock()
	defer fake.getUserInfoMutex.Unlock()
	fake.GetUserInfoStub = stub
}

func (fake *FakeOAuthService) GetUserInfoArgsForCall(i int) (context.Context, string) {
	fake.getUserInfoMutex.RLock()
	defer fake.getUserInfoMutex.RUnlock()
	argsForCall := fake.getUserInfoArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeOAuthService) GetUserInfoReturns(result1 map[string]interface{}, result2 error) {
	fake.getUserInfoMutex.Lock()
	defer fake.getUserInfoMutex.Unlock()
	fake.GetUserInfoStub = nil
	fake.getUserInfoReturns = struct {
		result1 map[string]interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakeOAuthService) GetUserInfoReturnsOnCall(i int, result1 map[string]interface{}, result2 error) {
	fake.getUserInfoMutex.Lock()
	defer fake.getUserInfoMutex.Unlock()
	fake.GetUserInfoStub = nil
	if fake.getUserInfoReturnsOnCall == nil {
		fake.getUserInfoReturnsOnCall = make(map[int]struct {
			result1 map[string]interface{}
			result2 error
		})
	}
	fake.getUserInfoReturnsOnCall[i] = struct {
		result1 map[string]interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakeOAuthService) GetUserInfoByEmail(arg1 context.Context, arg2 string) (map[string]interface{}, error) {
	fake.getUserInfoByEmailMutex.Lock()
	ret, specificReturn := fake.getUserInfoByEmailReturnsOnCall[len(fake.getUserInfoByEmailArgsForCall)]
	fake.getUserInfoByEmailArgsForCall = append(fake.getUserInfoByEmailArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.GetUserInfoByEmailStub
	fakeReturns := fake.getUserInfoByEmailReturns
	fake.recordInvocation("GetUserInfoByEmail", []interface{}{arg1, arg2})
	fake.getUserInfoByEmailMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeOAuthService) GetUserInfoByEmailCallCount() int {
	fake.getUserInfoByEmailMutex.RLock()
	defer fake.getUserInfoByEmailMutex.RUnlock()
	return len(fake.getUserInfoByEmailArgsForCall)
}

func (fake *FakeOAuthService) GetUserInfoByEmailCalls(stub func(context.Context, string) (map[string]interface{}, error)) {
	fake.getUserInfoByEmailMutex.Lock()
	defer fake.getUserInfoByEmailMutex.Unlock()
	fake.GetUserInfoByEmailStub = stub
}

func (fake *FakeOAuthService) GetUserInfoByEmailArgsForCall(i int) (context.Context, string) {
	fake.getUserInfoByEmailMutex.RLock()
	defer fake.getUserInfoByEmailMutex.RUnlock()
	argsForCall := fake.getUserInfoByEmailArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeOAuthService) GetUserInfoByEmailReturns(result1 map[string]interface{}, result2 error) {
	fake.getUserInfoByEmailMutex.Lock()
	defer fake.getUserInfoByEmailMutex.Unlock()
	fake.GetUserInfoByEmailStub = nil
	fake.getUserInfoByEmailReturns = struct {
		result1 map[string]interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakeOAuthService) GetUserInfoByEmailReturnsOnCall(i int, result1 map[string]interface{}, result2 error) {
	fake.getUserInfoByEmailMutex.Lock()
	defer fake.getUserInfoByEmailMutex.Unlock()
	fake.GetUserInfoByEmailStub = nil
	if fake.getUserInfoByEmailReturnsOnCall == nil {
		fake.getUserInfoByEmailReturnsOnCall = make(map[int]struct {
			result1 map[string]interface{}
			result2 error
		})
	}
	fake.getUserInfoByEmailReturnsOnCall[i] = struct {
		result1 map[string]interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakeOAuthService) ValidateWebAuthToken(arg1 context.Context, arg2 string) (map[string]interface{}, error) {
	fake.validateWebAuthTokenMutex.Lock()
	ret, specificReturn := fake.validateWebAuthTokenReturnsOnCall[len(fake.validateWebAuthTokenArgsForCall)]
	fake.validateWebAuthTokenArgsForCall = append(fake.validateWebAuthTokenArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.ValidateWebAuthTokenStub
	fakeReturns := fake.validateWebAuthTokenReturns
	fake.recordInvocation("ValidateWebAuthToken", []interface{}{arg1, arg2})
	fake.validateWebAuthTokenMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeOAuthService) ValidateWebAuthTokenCallCount() int {
	fake.validateWebAuthTokenMutex.RLock()
	defer fake.validateWebAuthTokenMutex.RUnlock()
	return len(fake.validateWebAuthTokenArgsForCall)
}

func (fake *FakeOAuthService) ValidateWebAuthTokenCalls(stub func(context.Context, string) (map[string]interface{}, error)) {
	fake.validateWebAuthTokenMutex.Lock()
	defer fake.validateWebAuthTokenMutex.Unlock()
	fake.ValidateWebAuthTokenStub = stub
}

func (fake *FakeOAuthService) ValidateWebAuthTokenArgsForCall(i int) (context.Context, string) {
	fake.validateWebAuthTokenMutex.RLock()
	defer fake.validateWebAuthTokenMutex.RUnlock()
	argsForCall := fake.validateWebAuthTokenArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeOAuthService) ValidateWebAuthTokenReturns(result1 map[string]interface{}, result2 error) {
	fake.validateWebAuthTokenMutex.Lock()
	defer fake.validateWebAuthTokenMutex.Unlock()
	fake.ValidateWebAuthTokenStub = nil
	fake.validateWebAuthTokenReturns = struct {
		result1 map[string]interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakeOAuthService) ValidateWebAuthTokenReturnsOnCall(i int, result1 map[string]interface{}, result2 error) {
	fake.validateWebAuthTokenMutex.Lock()
	defer fake.validateWebAuthTokenMutex.Unlock()
	fake.ValidateWebAuthTokenStub = nil
	if fake.validateWebAuthTokenReturnsOnCall == nil {
		fake.validateWebAuthTokenReturnsOnCall = make(map[int]struct {
			result1 map[string]interface{}
			result2 error
		})
	}
	fake.validateWebAuthTokenReturnsOnCall[i] = struct {
		result1 map[string]interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakeOAuthService) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.getUserInfoMutex.RLock()
	defer fake.getUserInfoMutex.RUnlock()
	fake.getUserInfoByEmailMutex.RLock()
	defer fake.getUserInfoByEmailMutex.RUnlock()
	fake.validateWebAuthTokenMutex.RLock()
	defer fake.validateWebAuthTokenMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeOAuthService) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ ports.OAuthService = new(FakeOAuthService)
