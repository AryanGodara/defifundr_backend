// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"context"
	"sync"

	"github.com/demola234/defifundr/internal/core/domain"
	"github.com/demola234/defifundr/internal/core/ports"
	"github.com/google/uuid"
)

type FakeAuthService struct {
	LoginStub        func(context.Context, string, string, string, string, string, string) (*domain.Session, *domain.User, error)
	loginMutex       sync.RWMutex
	loginArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
		arg5 string
		arg6 string
		arg7 string
	}
	loginReturns struct {
		result1 *domain.Session
		result2 *domain.User
		result3 error
	}
	loginReturnsOnCall map[int]struct {
		result1 *domain.Session
		result2 *domain.User
		result3 error
	}
	LogoutStub        func(context.Context, uuid.UUID) error
	logoutMutex       sync.RWMutex
	logoutArgsForCall []struct {
		arg1 context.Context
		arg2 uuid.UUID
	}
	logoutReturns struct {
		result1 error
	}
	logoutReturnsOnCall map[int]struct {
		result1 error
	}
	RefreshTokenStub        func(context.Context, string, string, string) (*domain.Session, string, error)
	refreshTokenMutex       sync.RWMutex
	refreshTokenArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}
	refreshTokenReturns struct {
		result1 *domain.Session
		result2 string
		result3 error
	}
	refreshTokenReturnsOnCall map[int]struct {
		result1 *domain.Session
		result2 string
		result3 error
	}
	RegisterAddressDetailsStub        func(context.Context, domain.User, string) (*domain.User, error)
	registerAddressDetailsMutex       sync.RWMutex
	registerAddressDetailsArgsForCall []struct {
		arg1 context.Context
		arg2 domain.User
		arg3 string
	}
	registerAddressDetailsReturns struct {
		result1 *domain.User
		result2 error
	}
	registerAddressDetailsReturnsOnCall map[int]struct {
		result1 *domain.User
		result2 error
	}
	RegisterBusinessStub        func(context.Context, domain.User, string) (*domain.User, error)
	registerBusinessMutex       sync.RWMutex
	registerBusinessArgsForCall []struct {
		arg1 context.Context
		arg2 domain.User
		arg3 string
	}
	registerBusinessReturns struct {
		result1 *domain.User
		result2 error
	}
	registerBusinessReturnsOnCall map[int]struct {
		result1 *domain.User
		result2 error
	}
	RegisterBusinessDetailsStub        func(context.Context, domain.User, string) (*domain.User, error)
	registerBusinessDetailsMutex       sync.RWMutex
	registerBusinessDetailsArgsForCall []struct {
		arg1 context.Context
		arg2 domain.User
		arg3 string
	}
	registerBusinessDetailsReturns struct {
		result1 *domain.User
		result2 error
	}
	registerBusinessDetailsReturnsOnCall map[int]struct {
		result1 *domain.User
		result2 error
	}
	RegisterPersonalDetailsStub        func(context.Context, domain.User, string) (*domain.User, error)
	registerPersonalDetailsMutex       sync.RWMutex
	registerPersonalDetailsArgsForCall []struct {
		arg1 context.Context
		arg2 domain.User
		arg3 string
	}
	registerPersonalDetailsReturns struct {
		result1 *domain.User
		result2 error
	}
	registerPersonalDetailsReturnsOnCall map[int]struct {
		result1 *domain.User
		result2 error
	}
	RegisterUserStub        func(context.Context, domain.User, string) (*domain.User, error)
	registerUserMutex       sync.RWMutex
	registerUserArgsForCall []struct {
		arg1 context.Context
		arg2 domain.User
		arg3 string
	}
	registerUserReturns struct {
		result1 *domain.User
		result2 error
	}
	registerUserReturnsOnCall map[int]struct {
		result1 *domain.User
		result2 error
	}
	ResetPasswordStub        func(context.Context, string, string, string) error
	resetPasswordMutex       sync.RWMutex
	resetPasswordArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}
	resetPasswordReturns struct {
		result1 error
	}
	resetPasswordReturnsOnCall map[int]struct {
		result1 error
	}
	SendPasswordResetEmailStub        func(context.Context, string) error
	sendPasswordResetEmailMutex       sync.RWMutex
	sendPasswordResetEmailArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	sendPasswordResetEmailReturns struct {
		result1 error
	}
	sendPasswordResetEmailReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeAuthService) Login(arg1 context.Context, arg2 string, arg3 string, arg4 string, arg5 string, arg6 string, arg7 string) (*domain.Session, *domain.User, error) {
	fake.loginMutex.Lock()
	ret, specificReturn := fake.loginReturnsOnCall[len(fake.loginArgsForCall)]
	fake.loginArgsForCall = append(fake.loginArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
		arg5 string
		arg6 string
		arg7 string
	}{arg1, arg2, arg3, arg4, arg5, arg6, arg7})
	stub := fake.LoginStub
	fakeReturns := fake.loginReturns
	fake.recordInvocation("Login", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6, arg7})
	fake.loginMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5, arg6, arg7)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeAuthService) LoginCallCount() int {
	fake.loginMutex.RLock()
	defer fake.loginMutex.RUnlock()
	return len(fake.loginArgsForCall)
}

func (fake *FakeAuthService) LoginCalls(stub func(context.Context, string, string, string, string, string, string) (*domain.Session, *domain.User, error)) {
	fake.loginMutex.Lock()
	defer fake.loginMutex.Unlock()
	fake.LoginStub = stub
}

func (fake *FakeAuthService) LoginArgsForCall(i int) (context.Context, string, string, string, string, string, string) {
	fake.loginMutex.RLock()
	defer fake.loginMutex.RUnlock()
	argsForCall := fake.loginArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6, argsForCall.arg7
}

func (fake *FakeAuthService) LoginReturns(result1 *domain.Session, result2 *domain.User, result3 error) {
	fake.loginMutex.Lock()
	defer fake.loginMutex.Unlock()
	fake.LoginStub = nil
	fake.loginReturns = struct {
		result1 *domain.Session
		result2 *domain.User
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeAuthService) LoginReturnsOnCall(i int, result1 *domain.Session, result2 *domain.User, result3 error) {
	fake.loginMutex.Lock()
	defer fake.loginMutex.Unlock()
	fake.LoginStub = nil
	if fake.loginReturnsOnCall == nil {
		fake.loginReturnsOnCall = make(map[int]struct {
			result1 *domain.Session
			result2 *domain.User
			result3 error
		})
	}
	fake.loginReturnsOnCall[i] = struct {
		result1 *domain.Session
		result2 *domain.User
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeAuthService) Logout(arg1 context.Context, arg2 uuid.UUID) error {
	fake.logoutMutex.Lock()
	ret, specificReturn := fake.logoutReturnsOnCall[len(fake.logoutArgsForCall)]
	fake.logoutArgsForCall = append(fake.logoutArgsForCall, struct {
		arg1 context.Context
		arg2 uuid.UUID
	}{arg1, arg2})
	stub := fake.LogoutStub
	fakeReturns := fake.logoutReturns
	fake.recordInvocation("Logout", []interface{}{arg1, arg2})
	fake.logoutMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeAuthService) LogoutCallCount() int {
	fake.logoutMutex.RLock()
	defer fake.logoutMutex.RUnlock()
	return len(fake.logoutArgsForCall)
}

func (fake *FakeAuthService) LogoutCalls(stub func(context.Context, uuid.UUID) error) {
	fake.logoutMutex.Lock()
	defer fake.logoutMutex.Unlock()
	fake.LogoutStub = stub
}

func (fake *FakeAuthService) LogoutArgsForCall(i int) (context.Context, uuid.UUID) {
	fake.logoutMutex.RLock()
	defer fake.logoutMutex.RUnlock()
	argsForCall := fake.logoutArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeAuthService) LogoutReturns(result1 error) {
	fake.logoutMutex.Lock()
	defer fake.logoutMutex.Unlock()
	fake.LogoutStub = nil
	fake.logoutReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeAuthService) LogoutReturnsOnCall(i int, result1 error) {
	fake.logoutMutex.Lock()
	defer fake.logoutMutex.Unlock()
	fake.LogoutStub = nil
	if fake.logoutReturnsOnCall == nil {
		fake.logoutReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.logoutReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeAuthService) RefreshToken(arg1 context.Context, arg2 string, arg3 string, arg4 string) (*domain.Session, string, error) {
	fake.refreshTokenMutex.Lock()
	ret, specificReturn := fake.refreshTokenReturnsOnCall[len(fake.refreshTokenArgsForCall)]
	fake.refreshTokenArgsForCall = append(fake.refreshTokenArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.RefreshTokenStub
	fakeReturns := fake.refreshTokenReturns
	fake.recordInvocation("RefreshToken", []interface{}{arg1, arg2, arg3, arg4})
	fake.refreshTokenMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeAuthService) RefreshTokenCallCount() int {
	fake.refreshTokenMutex.RLock()
	defer fake.refreshTokenMutex.RUnlock()
	return len(fake.refreshTokenArgsForCall)
}

func (fake *FakeAuthService) RefreshTokenCalls(stub func(context.Context, string, string, string) (*domain.Session, string, error)) {
	fake.refreshTokenMutex.Lock()
	defer fake.refreshTokenMutex.Unlock()
	fake.RefreshTokenStub = stub
}

func (fake *FakeAuthService) RefreshTokenArgsForCall(i int) (context.Context, string, string, string) {
	fake.refreshTokenMutex.RLock()
	defer fake.refreshTokenMutex.RUnlock()
	argsForCall := fake.refreshTokenArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeAuthService) RefreshTokenReturns(result1 *domain.Session, result2 string, result3 error) {
	fake.refreshTokenMutex.Lock()
	defer fake.refreshTokenMutex.Unlock()
	fake.RefreshTokenStub = nil
	fake.refreshTokenReturns = struct {
		result1 *domain.Session
		result2 string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeAuthService) RefreshTokenReturnsOnCall(i int, result1 *domain.Session, result2 string, result3 error) {
	fake.refreshTokenMutex.Lock()
	defer fake.refreshTokenMutex.Unlock()
	fake.RefreshTokenStub = nil
	if fake.refreshTokenReturnsOnCall == nil {
		fake.refreshTokenReturnsOnCall = make(map[int]struct {
			result1 *domain.Session
			result2 string
			result3 error
		})
	}
	fake.refreshTokenReturnsOnCall[i] = struct {
		result1 *domain.Session
		result2 string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeAuthService) RegisterAddressDetails(arg1 context.Context, arg2 domain.User, arg3 string) (*domain.User, error) {
	fake.registerAddressDetailsMutex.Lock()
	ret, specificReturn := fake.registerAddressDetailsReturnsOnCall[len(fake.registerAddressDetailsArgsForCall)]
	fake.registerAddressDetailsArgsForCall = append(fake.registerAddressDetailsArgsForCall, struct {
		arg1 context.Context
		arg2 domain.User
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.RegisterAddressDetailsStub
	fakeReturns := fake.registerAddressDetailsReturns
	fake.recordInvocation("RegisterAddressDetails", []interface{}{arg1, arg2, arg3})
	fake.registerAddressDetailsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAuthService) RegisterAddressDetailsCallCount() int {
	fake.registerAddressDetailsMutex.RLock()
	defer fake.registerAddressDetailsMutex.RUnlock()
	return len(fake.registerAddressDetailsArgsForCall)
}

func (fake *FakeAuthService) RegisterAddressDetailsCalls(stub func(context.Context, domain.User, string) (*domain.User, error)) {
	fake.registerAddressDetailsMutex.Lock()
	defer fake.registerAddressDetailsMutex.Unlock()
	fake.RegisterAddressDetailsStub = stub
}

func (fake *FakeAuthService) RegisterAddressDetailsArgsForCall(i int) (context.Context, domain.User, string) {
	fake.registerAddressDetailsMutex.RLock()
	defer fake.registerAddressDetailsMutex.RUnlock()
	argsForCall := fake.registerAddressDetailsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeAuthService) RegisterAddressDetailsReturns(result1 *domain.User, result2 error) {
	fake.registerAddressDetailsMutex.Lock()
	defer fake.registerAddressDetailsMutex.Unlock()
	fake.RegisterAddressDetailsStub = nil
	fake.registerAddressDetailsReturns = struct {
		result1 *domain.User
		result2 error
	}{result1, result2}
}

func (fake *FakeAuthService) RegisterAddressDetailsReturnsOnCall(i int, result1 *domain.User, result2 error) {
	fake.registerAddressDetailsMutex.Lock()
	defer fake.registerAddressDetailsMutex.Unlock()
	fake.RegisterAddressDetailsStub = nil
	if fake.registerAddressDetailsReturnsOnCall == nil {
		fake.registerAddressDetailsReturnsOnCall = make(map[int]struct {
			result1 *domain.User
			result2 error
		})
	}
	fake.registerAddressDetailsReturnsOnCall[i] = struct {
		result1 *domain.User
		result2 error
	}{result1, result2}
}

func (fake *FakeAuthService) RegisterBusiness(arg1 context.Context, arg2 domain.User, arg3 string) (*domain.User, error) {
	fake.registerBusinessMutex.Lock()
	ret, specificReturn := fake.registerBusinessReturnsOnCall[len(fake.registerBusinessArgsForCall)]
	fake.registerBusinessArgsForCall = append(fake.registerBusinessArgsForCall, struct {
		arg1 context.Context
		arg2 domain.User
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.RegisterBusinessStub
	fakeReturns := fake.registerBusinessReturns
	fake.recordInvocation("RegisterBusiness", []interface{}{arg1, arg2, arg3})
	fake.registerBusinessMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAuthService) RegisterBusinessCallCount() int {
	fake.registerBusinessMutex.RLock()
	defer fake.registerBusinessMutex.RUnlock()
	return len(fake.registerBusinessArgsForCall)
}

func (fake *FakeAuthService) RegisterBusinessCalls(stub func(context.Context, domain.User, string) (*domain.User, error)) {
	fake.registerBusinessMutex.Lock()
	defer fake.registerBusinessMutex.Unlock()
	fake.RegisterBusinessStub = stub
}

func (fake *FakeAuthService) RegisterBusinessArgsForCall(i int) (context.Context, domain.User, string) {
	fake.registerBusinessMutex.RLock()
	defer fake.registerBusinessMutex.RUnlock()
	argsForCall := fake.registerBusinessArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeAuthService) RegisterBusinessReturns(result1 *domain.User, result2 error) {
	fake.registerBusinessMutex.Lock()
	defer fake.registerBusinessMutex.Unlock()
	fake.RegisterBusinessStub = nil
	fake.registerBusinessReturns = struct {
		result1 *domain.User
		result2 error
	}{result1, result2}
}

func (fake *FakeAuthService) RegisterBusinessReturnsOnCall(i int, result1 *domain.User, result2 error) {
	fake.registerBusinessMutex.Lock()
	defer fake.registerBusinessMutex.Unlock()
	fake.RegisterBusinessStub = nil
	if fake.registerBusinessReturnsOnCall == nil {
		fake.registerBusinessReturnsOnCall = make(map[int]struct {
			result1 *domain.User
			result2 error
		})
	}
	fake.registerBusinessReturnsOnCall[i] = struct {
		result1 *domain.User
		result2 error
	}{result1, result2}
}

func (fake *FakeAuthService) RegisterBusinessDetails(arg1 context.Context, arg2 domain.User, arg3 string) (*domain.User, error) {
	fake.registerBusinessDetailsMutex.Lock()
	ret, specificReturn := fake.registerBusinessDetailsReturnsOnCall[len(fake.registerBusinessDetailsArgsForCall)]
	fake.registerBusinessDetailsArgsForCall = append(fake.registerBusinessDetailsArgsForCall, struct {
		arg1 context.Context
		arg2 domain.User
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.RegisterBusinessDetailsStub
	fakeReturns := fake.registerBusinessDetailsReturns
	fake.recordInvocation("RegisterBusinessDetails", []interface{}{arg1, arg2, arg3})
	fake.registerBusinessDetailsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAuthService) RegisterBusinessDetailsCallCount() int {
	fake.registerBusinessDetailsMutex.RLock()
	defer fake.registerBusinessDetailsMutex.RUnlock()
	return len(fake.registerBusinessDetailsArgsForCall)
}

func (fake *FakeAuthService) RegisterBusinessDetailsCalls(stub func(context.Context, domain.User, string) (*domain.User, error)) {
	fake.registerBusinessDetailsMutex.Lock()
	defer fake.registerBusinessDetailsMutex.Unlock()
	fake.RegisterBusinessDetailsStub = stub
}

func (fake *FakeAuthService) RegisterBusinessDetailsArgsForCall(i int) (context.Context, domain.User, string) {
	fake.registerBusinessDetailsMutex.RLock()
	defer fake.registerBusinessDetailsMutex.RUnlock()
	argsForCall := fake.registerBusinessDetailsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeAuthService) RegisterBusinessDetailsReturns(result1 *domain.User, result2 error) {
	fake.registerBusinessDetailsMutex.Lock()
	defer fake.registerBusinessDetailsMutex.Unlock()
	fake.RegisterBusinessDetailsStub = nil
	fake.registerBusinessDetailsReturns = struct {
		result1 *domain.User
		result2 error
	}{result1, result2}
}

func (fake *FakeAuthService) RegisterBusinessDetailsReturnsOnCall(i int, result1 *domain.User, result2 error) {
	fake.registerBusinessDetailsMutex.Lock()
	defer fake.registerBusinessDetailsMutex.Unlock()
	fake.RegisterBusinessDetailsStub = nil
	if fake.registerBusinessDetailsReturnsOnCall == nil {
		fake.registerBusinessDetailsReturnsOnCall = make(map[int]struct {
			result1 *domain.User
			result2 error
		})
	}
	fake.registerBusinessDetailsReturnsOnCall[i] = struct {
		result1 *domain.User
		result2 error
	}{result1, result2}
}

func (fake *FakeAuthService) RegisterPersonalDetails(arg1 context.Context, arg2 domain.User, arg3 string) (*domain.User, error) {
	fake.registerPersonalDetailsMutex.Lock()
	ret, specificReturn := fake.registerPersonalDetailsReturnsOnCall[len(fake.registerPersonalDetailsArgsForCall)]
	fake.registerPersonalDetailsArgsForCall = append(fake.registerPersonalDetailsArgsForCall, struct {
		arg1 context.Context
		arg2 domain.User
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.RegisterPersonalDetailsStub
	fakeReturns := fake.registerPersonalDetailsReturns
	fake.recordInvocation("RegisterPersonalDetails", []interface{}{arg1, arg2, arg3})
	fake.registerPersonalDetailsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAuthService) RegisterPersonalDetailsCallCount() int {
	fake.registerPersonalDetailsMutex.RLock()
	defer fake.registerPersonalDetailsMutex.RUnlock()
	return len(fake.registerPersonalDetailsArgsForCall)
}

func (fake *FakeAuthService) RegisterPersonalDetailsCalls(stub func(context.Context, domain.User, string) (*domain.User, error)) {
	fake.registerPersonalDetailsMutex.Lock()
	defer fake.registerPersonalDetailsMutex.Unlock()
	fake.RegisterPersonalDetailsStub = stub
}

func (fake *FakeAuthService) RegisterPersonalDetailsArgsForCall(i int) (context.Context, domain.User, string) {
	fake.registerPersonalDetailsMutex.RLock()
	defer fake.registerPersonalDetailsMutex.RUnlock()
	argsForCall := fake.registerPersonalDetailsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeAuthService) RegisterPersonalDetailsReturns(result1 *domain.User, result2 error) {
	fake.registerPersonalDetailsMutex.Lock()
	defer fake.registerPersonalDetailsMutex.Unlock()
	fake.RegisterPersonalDetailsStub = nil
	fake.registerPersonalDetailsReturns = struct {
		result1 *domain.User
		result2 error
	}{result1, result2}
}

func (fake *FakeAuthService) RegisterPersonalDetailsReturnsOnCall(i int, result1 *domain.User, result2 error) {
	fake.registerPersonalDetailsMutex.Lock()
	defer fake.registerPersonalDetailsMutex.Unlock()
	fake.RegisterPersonalDetailsStub = nil
	if fake.registerPersonalDetailsReturnsOnCall == nil {
		fake.registerPersonalDetailsReturnsOnCall = make(map[int]struct {
			result1 *domain.User
			result2 error
		})
	}
	fake.registerPersonalDetailsReturnsOnCall[i] = struct {
		result1 *domain.User
		result2 error
	}{result1, result2}
}

func (fake *FakeAuthService) RegisterUser(arg1 context.Context, arg2 domain.User, arg3 string) (*domain.User, error) {
	fake.registerUserMutex.Lock()
	ret, specificReturn := fake.registerUserReturnsOnCall[len(fake.registerUserArgsForCall)]
	fake.registerUserArgsForCall = append(fake.registerUserArgsForCall, struct {
		arg1 context.Context
		arg2 domain.User
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.RegisterUserStub
	fakeReturns := fake.registerUserReturns
	fake.recordInvocation("RegisterUser", []interface{}{arg1, arg2, arg3})
	fake.registerUserMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAuthService) RegisterUserCallCount() int {
	fake.registerUserMutex.RLock()
	defer fake.registerUserMutex.RUnlock()
	return len(fake.registerUserArgsForCall)
}

func (fake *FakeAuthService) RegisterUserCalls(stub func(context.Context, domain.User, string) (*domain.User, error)) {
	fake.registerUserMutex.Lock()
	defer fake.registerUserMutex.Unlock()
	fake.RegisterUserStub = stub
}

func (fake *FakeAuthService) RegisterUserArgsForCall(i int) (context.Context, domain.User, string) {
	fake.registerUserMutex.RLock()
	defer fake.registerUserMutex.RUnlock()
	argsForCall := fake.registerUserArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeAuthService) RegisterUserReturns(result1 *domain.User, result2 error) {
	fake.registerUserMutex.Lock()
	defer fake.registerUserMutex.Unlock()
	fake.RegisterUserStub = nil
	fake.registerUserReturns = struct {
		result1 *domain.User
		result2 error
	}{result1, result2}
}

func (fake *FakeAuthService) RegisterUserReturnsOnCall(i int, result1 *domain.User, result2 error) {
	fake.registerUserMutex.Lock()
	defer fake.registerUserMutex.Unlock()
	fake.RegisterUserStub = nil
	if fake.registerUserReturnsOnCall == nil {
		fake.registerUserReturnsOnCall = make(map[int]struct {
			result1 *domain.User
			result2 error
		})
	}
	fake.registerUserReturnsOnCall[i] = struct {
		result1 *domain.User
		result2 error
	}{result1, result2}
}

func (fake *FakeAuthService) ResetPassword(arg1 context.Context, arg2 string, arg3 string, arg4 string) error {
	fake.resetPasswordMutex.Lock()
	ret, specificReturn := fake.resetPasswordReturnsOnCall[len(fake.resetPasswordArgsForCall)]
	fake.resetPasswordArgsForCall = append(fake.resetPasswordArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.ResetPasswordStub
	fakeReturns := fake.resetPasswordReturns
	fake.recordInvocation("ResetPassword", []interface{}{arg1, arg2, arg3, arg4})
	fake.resetPasswordMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeAuthService) ResetPasswordCallCount() int {
	fake.resetPasswordMutex.RLock()
	defer fake.resetPasswordMutex.RUnlock()
	return len(fake.resetPasswordArgsForCall)
}

func (fake *FakeAuthService) ResetPasswordCalls(stub func(context.Context, string, string, string) error) {
	fake.resetPasswordMutex.Lock()
	defer fake.resetPasswordMutex.Unlock()
	fake.ResetPasswordStub = stub
}

func (fake *FakeAuthService) ResetPasswordArgsForCall(i int) (context.Context, string, string, string) {
	fake.resetPasswordMutex.RLock()
	defer fake.resetPasswordMutex.RUnlock()
	argsForCall := fake.resetPasswordArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeAuthService) ResetPasswordReturns(result1 error) {
	fake.resetPasswordMutex.Lock()
	defer fake.resetPasswordMutex.Unlock()
	fake.ResetPasswordStub = nil
	fake.resetPasswordReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeAuthService) ResetPasswordReturnsOnCall(i int, result1 error) {
	fake.resetPasswordMutex.Lock()
	defer fake.resetPasswordMutex.Unlock()
	fake.ResetPasswordStub = nil
	if fake.resetPasswordReturnsOnCall == nil {
		fake.resetPasswordReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.resetPasswordReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeAuthService) SendPasswordResetEmail(arg1 context.Context, arg2 string) error {
	fake.sendPasswordResetEmailMutex.Lock()
	ret, specificReturn := fake.sendPasswordResetEmailReturnsOnCall[len(fake.sendPasswordResetEmailArgsForCall)]
	fake.sendPasswordResetEmailArgsForCall = append(fake.sendPasswordResetEmailArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.SendPasswordResetEmailStub
	fakeReturns := fake.sendPasswordResetEmailReturns
	fake.recordInvocation("SendPasswordResetEmail", []interface{}{arg1, arg2})
	fake.sendPasswordResetEmailMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeAuthService) SendPasswordResetEmailCallCount() int {
	fake.sendPasswordResetEmailMutex.RLock()
	defer fake.sendPasswordResetEmailMutex.RUnlock()
	return len(fake.sendPasswordResetEmailArgsForCall)
}

func (fake *FakeAuthService) SendPasswordResetEmailCalls(stub func(context.Context, string) error) {
	fake.sendPasswordResetEmailMutex.Lock()
	defer fake.sendPasswordResetEmailMutex.Unlock()
	fake.SendPasswordResetEmailStub = stub
}

func (fake *FakeAuthService) SendPasswordResetEmailArgsForCall(i int) (context.Context, string) {
	fake.sendPasswordResetEmailMutex.RLock()
	defer fake.sendPasswordResetEmailMutex.RUnlock()
	argsForCall := fake.sendPasswordResetEmailArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeAuthService) SendPasswordResetEmailReturns(result1 error) {
	fake.sendPasswordResetEmailMutex.Lock()
	defer fake.sendPasswordResetEmailMutex.Unlock()
	fake.SendPasswordResetEmailStub = nil
	fake.sendPasswordResetEmailReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeAuthService) SendPasswordResetEmailReturnsOnCall(i int, result1 error) {
	fake.sendPasswordResetEmailMutex.Lock()
	defer fake.sendPasswordResetEmailMutex.Unlock()
	fake.SendPasswordResetEmailStub = nil
	if fake.sendPasswordResetEmailReturnsOnCall == nil {
		fake.sendPasswordResetEmailReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.sendPasswordResetEmailReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeAuthService) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.loginMutex.RLock()
	defer fake.loginMutex.RUnlock()
	fake.logoutMutex.RLock()
	defer fake.logoutMutex.RUnlock()
	fake.refreshTokenMutex.RLock()
	defer fake.refreshTokenMutex.RUnlock()
	fake.registerAddressDetailsMutex.RLock()
	defer fake.registerAddressDetailsMutex.RUnlock()
	fake.registerBusinessMutex.RLock()
	defer fake.registerBusinessMutex.RUnlock()
	fake.registerBusinessDetailsMutex.RLock()
	defer fake.registerBusinessDetailsMutex.RUnlock()
	fake.registerPersonalDetailsMutex.RLock()
	defer fake.registerPersonalDetailsMutex.RUnlock()
	fake.registerUserMutex.RLock()
	defer fake.registerUserMutex.RUnlock()
	fake.resetPasswordMutex.RLock()
	defer fake.resetPasswordMutex.RUnlock()
	fake.sendPasswordResetEmailMutex.RLock()
	defer fake.sendPasswordResetEmailMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeAuthService) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ ports.AuthService = new(FakeAuthService)
