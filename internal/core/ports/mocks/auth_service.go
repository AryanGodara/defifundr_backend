// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"context"
	"sync"

	"github.com/demola234/defifundr/internal/core/domain"
	"github.com/demola234/defifundr/internal/core/ports"
	"github.com/google/uuid"
)

type FakeAuthService struct {
	CheckEmailExistsStub        func(context.Context, string) (bool, error)
	checkEmailExistsMutex       sync.RWMutex
	checkEmailExistsArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	checkEmailExistsReturns struct {
		result1 bool
		result2 error
	}
	checkEmailExistsReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	CreateSessionStub        func(context.Context, string, string, string, string, string, string) (*domain.Session, error)
	createSessionMutex       sync.RWMutex
	createSessionArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
		arg5 string
		arg6 string
		arg7 string
	}
	createSessionReturns struct {
		result1 *domain.Session
		result2 error
	}
	createSessionReturnsOnCall map[int]struct {
		result1 *domain.Session
		result2 error
	}
	GetUserByEmailStub        func(context.Context, string) (*domain.User, error)
	getUserByEmailMutex       sync.RWMutex
	getUserByEmailArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	getUserByEmailReturns struct {
		result1 *domain.User
		result2 error
	}
	getUserByEmailReturnsOnCall map[int]struct {
		result1 *domain.User
		result2 error
	}
	GetUserByIDStub        func(context.Context, uuid.UUID) (*domain.User, error)
	getUserByIDMutex       sync.RWMutex
	getUserByIDArgsForCall []struct {
		arg1 context.Context
		arg2 uuid.UUID
	}
	getUserByIDReturns struct {
		result1 *domain.User
		result2 error
	}
	getUserByIDReturnsOnCall map[int]struct {
		result1 *domain.User
		result2 error
	}
	LoginStub        func(context.Context, string, string, string, string, string, string) (*domain.Session, *domain.User, error)
	loginMutex       sync.RWMutex
	loginArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
		arg5 string
		arg6 string
		arg7 string
	}
	loginReturns struct {
		result1 *domain.Session
		result2 *domain.User
		result3 error
	}
	loginReturnsOnCall map[int]struct {
		result1 *domain.Session
		result2 *domain.User
		result3 error
	}
	LogoutStub        func(context.Context, uuid.UUID) error
	logoutMutex       sync.RWMutex
	logoutArgsForCall []struct {
		arg1 context.Context
		arg2 uuid.UUID
	}
	logoutReturns struct {
		result1 error
	}
	logoutReturnsOnCall map[int]struct {
		result1 error
	}
	RefreshTokenStub        func(context.Context, string, string, string) (*domain.Session, string, error)
	refreshTokenMutex       sync.RWMutex
	refreshTokenArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}
	refreshTokenReturns struct {
		result1 *domain.Session
		result2 string
		result3 error
	}
	refreshTokenReturnsOnCall map[int]struct {
		result1 *domain.Session
		result2 string
		result3 error
	}
	RegisterAddressDetailsStub        func(context.Context, domain.User) (*domain.User, error)
	registerAddressDetailsMutex       sync.RWMutex
	registerAddressDetailsArgsForCall []struct {
		arg1 context.Context
		arg2 domain.User
	}
	registerAddressDetailsReturns struct {
		result1 *domain.User
		result2 error
	}
	registerAddressDetailsReturnsOnCall map[int]struct {
		result1 *domain.User
		result2 error
	}
	RegisterBusinessStub        func(context.Context, domain.User) (*domain.User, error)
	registerBusinessMutex       sync.RWMutex
	registerBusinessArgsForCall []struct {
		arg1 context.Context
		arg2 domain.User
	}
	registerBusinessReturns struct {
		result1 *domain.User
		result2 error
	}
	registerBusinessReturnsOnCall map[int]struct {
		result1 *domain.User
		result2 error
	}
	RegisterBusinessDetailsStub        func(context.Context, domain.User) (*domain.User, error)
	registerBusinessDetailsMutex       sync.RWMutex
	registerBusinessDetailsArgsForCall []struct {
		arg1 context.Context
		arg2 domain.User
	}
	registerBusinessDetailsReturns struct {
		result1 *domain.User
		result2 error
	}
	registerBusinessDetailsReturnsOnCall map[int]struct {
		result1 *domain.User
		result2 error
	}
	RegisterPersonalDetailsStub        func(context.Context, domain.User) (*domain.User, error)
	registerPersonalDetailsMutex       sync.RWMutex
	registerPersonalDetailsArgsForCall []struct {
		arg1 context.Context
		arg2 domain.User
	}
	registerPersonalDetailsReturns struct {
		result1 *domain.User
		result2 error
	}
	registerPersonalDetailsReturnsOnCall map[int]struct {
		result1 *domain.User
		result2 error
	}
	RegisterUserStub        func(context.Context, domain.User, string) (*domain.User, error)
	registerUserMutex       sync.RWMutex
	registerUserArgsForCall []struct {
		arg1 context.Context
		arg2 domain.User
		arg3 string
	}
	registerUserReturns struct {
		result1 *domain.User
		result2 error
	}
	registerUserReturnsOnCall map[int]struct {
		result1 *domain.User
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeAuthService) CheckEmailExists(arg1 context.Context, arg2 string) (bool, error) {
	fake.checkEmailExistsMutex.Lock()
	ret, specificReturn := fake.checkEmailExistsReturnsOnCall[len(fake.checkEmailExistsArgsForCall)]
	fake.checkEmailExistsArgsForCall = append(fake.checkEmailExistsArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.CheckEmailExistsStub
	fakeReturns := fake.checkEmailExistsReturns
	fake.recordInvocation("CheckEmailExists", []interface{}{arg1, arg2})
	fake.checkEmailExistsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAuthService) CheckEmailExistsCallCount() int {
	fake.checkEmailExistsMutex.RLock()
	defer fake.checkEmailExistsMutex.RUnlock()
	return len(fake.checkEmailExistsArgsForCall)
}

func (fake *FakeAuthService) CheckEmailExistsCalls(stub func(context.Context, string) (bool, error)) {
	fake.checkEmailExistsMutex.Lock()
	defer fake.checkEmailExistsMutex.Unlock()
	fake.CheckEmailExistsStub = stub
}

func (fake *FakeAuthService) CheckEmailExistsArgsForCall(i int) (context.Context, string) {
	fake.checkEmailExistsMutex.RLock()
	defer fake.checkEmailExistsMutex.RUnlock()
	argsForCall := fake.checkEmailExistsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeAuthService) CheckEmailExistsReturns(result1 bool, result2 error) {
	fake.checkEmailExistsMutex.Lock()
	defer fake.checkEmailExistsMutex.Unlock()
	fake.CheckEmailExistsStub = nil
	fake.checkEmailExistsReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeAuthService) CheckEmailExistsReturnsOnCall(i int, result1 bool, result2 error) {
	fake.checkEmailExistsMutex.Lock()
	defer fake.checkEmailExistsMutex.Unlock()
	fake.CheckEmailExistsStub = nil
	if fake.checkEmailExistsReturnsOnCall == nil {
		fake.checkEmailExistsReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.checkEmailExistsReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeAuthService) CreateSession(arg1 context.Context, arg2 string, arg3 string, arg4 string, arg5 string, arg6 string, arg7 string) (*domain.Session, error) {
	fake.createSessionMutex.Lock()
	ret, specificReturn := fake.createSessionReturnsOnCall[len(fake.createSessionArgsForCall)]
	fake.createSessionArgsForCall = append(fake.createSessionArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
		arg5 string
		arg6 string
		arg7 string
	}{arg1, arg2, arg3, arg4, arg5, arg6, arg7})
	stub := fake.CreateSessionStub
	fakeReturns := fake.createSessionReturns
	fake.recordInvocation("CreateSession", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6, arg7})
	fake.createSessionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5, arg6, arg7)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAuthService) CreateSessionCallCount() int {
	fake.createSessionMutex.RLock()
	defer fake.createSessionMutex.RUnlock()
	return len(fake.createSessionArgsForCall)
}

func (fake *FakeAuthService) CreateSessionCalls(stub func(context.Context, string, string, string, string, string, string) (*domain.Session, error)) {
	fake.createSessionMutex.Lock()
	defer fake.createSessionMutex.Unlock()
	fake.CreateSessionStub = stub
}

func (fake *FakeAuthService) CreateSessionArgsForCall(i int) (context.Context, string, string, string, string, string, string) {
	fake.createSessionMutex.RLock()
	defer fake.createSessionMutex.RUnlock()
	argsForCall := fake.createSessionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6, argsForCall.arg7
}

func (fake *FakeAuthService) CreateSessionReturns(result1 *domain.Session, result2 error) {
	fake.createSessionMutex.Lock()
	defer fake.createSessionMutex.Unlock()
	fake.CreateSessionStub = nil
	fake.createSessionReturns = struct {
		result1 *domain.Session
		result2 error
	}{result1, result2}
}

func (fake *FakeAuthService) CreateSessionReturnsOnCall(i int, result1 *domain.Session, result2 error) {
	fake.createSessionMutex.Lock()
	defer fake.createSessionMutex.Unlock()
	fake.CreateSessionStub = nil
	if fake.createSessionReturnsOnCall == nil {
		fake.createSessionReturnsOnCall = make(map[int]struct {
			result1 *domain.Session
			result2 error
		})
	}
	fake.createSessionReturnsOnCall[i] = struct {
		result1 *domain.Session
		result2 error
	}{result1, result2}
}

func (fake *FakeAuthService) GetUserByEmail(arg1 context.Context, arg2 string) (*domain.User, error) {
	fake.getUserByEmailMutex.Lock()
	ret, specificReturn := fake.getUserByEmailReturnsOnCall[len(fake.getUserByEmailArgsForCall)]
	fake.getUserByEmailArgsForCall = append(fake.getUserByEmailArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.GetUserByEmailStub
	fakeReturns := fake.getUserByEmailReturns
	fake.recordInvocation("GetUserByEmail", []interface{}{arg1, arg2})
	fake.getUserByEmailMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAuthService) GetUserByEmailCallCount() int {
	fake.getUserByEmailMutex.RLock()
	defer fake.getUserByEmailMutex.RUnlock()
	return len(fake.getUserByEmailArgsForCall)
}

func (fake *FakeAuthService) GetUserByEmailCalls(stub func(context.Context, string) (*domain.User, error)) {
	fake.getUserByEmailMutex.Lock()
	defer fake.getUserByEmailMutex.Unlock()
	fake.GetUserByEmailStub = stub
}

func (fake *FakeAuthService) GetUserByEmailArgsForCall(i int) (context.Context, string) {
	fake.getUserByEmailMutex.RLock()
	defer fake.getUserByEmailMutex.RUnlock()
	argsForCall := fake.getUserByEmailArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeAuthService) GetUserByEmailReturns(result1 *domain.User, result2 error) {
	fake.getUserByEmailMutex.Lock()
	defer fake.getUserByEmailMutex.Unlock()
	fake.GetUserByEmailStub = nil
	fake.getUserByEmailReturns = struct {
		result1 *domain.User
		result2 error
	}{result1, result2}
}

func (fake *FakeAuthService) GetUserByEmailReturnsOnCall(i int, result1 *domain.User, result2 error) {
	fake.getUserByEmailMutex.Lock()
	defer fake.getUserByEmailMutex.Unlock()
	fake.GetUserByEmailStub = nil
	if fake.getUserByEmailReturnsOnCall == nil {
		fake.getUserByEmailReturnsOnCall = make(map[int]struct {
			result1 *domain.User
			result2 error
		})
	}
	fake.getUserByEmailReturnsOnCall[i] = struct {
		result1 *domain.User
		result2 error
	}{result1, result2}
}

func (fake *FakeAuthService) GetUserByID(arg1 context.Context, arg2 uuid.UUID) (*domain.User, error) {
	fake.getUserByIDMutex.Lock()
	ret, specificReturn := fake.getUserByIDReturnsOnCall[len(fake.getUserByIDArgsForCall)]
	fake.getUserByIDArgsForCall = append(fake.getUserByIDArgsForCall, struct {
		arg1 context.Context
		arg2 uuid.UUID
	}{arg1, arg2})
	stub := fake.GetUserByIDStub
	fakeReturns := fake.getUserByIDReturns
	fake.recordInvocation("GetUserByID", []interface{}{arg1, arg2})
	fake.getUserByIDMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAuthService) GetUserByIDCallCount() int {
	fake.getUserByIDMutex.RLock()
	defer fake.getUserByIDMutex.RUnlock()
	return len(fake.getUserByIDArgsForCall)
}

func (fake *FakeAuthService) GetUserByIDCalls(stub func(context.Context, uuid.UUID) (*domain.User, error)) {
	fake.getUserByIDMutex.Lock()
	defer fake.getUserByIDMutex.Unlock()
	fake.GetUserByIDStub = stub
}

func (fake *FakeAuthService) GetUserByIDArgsForCall(i int) (context.Context, uuid.UUID) {
	fake.getUserByIDMutex.RLock()
	defer fake.getUserByIDMutex.RUnlock()
	argsForCall := fake.getUserByIDArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeAuthService) GetUserByIDReturns(result1 *domain.User, result2 error) {
	fake.getUserByIDMutex.Lock()
	defer fake.getUserByIDMutex.Unlock()
	fake.GetUserByIDStub = nil
	fake.getUserByIDReturns = struct {
		result1 *domain.User
		result2 error
	}{result1, result2}
}

func (fake *FakeAuthService) GetUserByIDReturnsOnCall(i int, result1 *domain.User, result2 error) {
	fake.getUserByIDMutex.Lock()
	defer fake.getUserByIDMutex.Unlock()
	fake.GetUserByIDStub = nil
	if fake.getUserByIDReturnsOnCall == nil {
		fake.getUserByIDReturnsOnCall = make(map[int]struct {
			result1 *domain.User
			result2 error
		})
	}
	fake.getUserByIDReturnsOnCall[i] = struct {
		result1 *domain.User
		result2 error
	}{result1, result2}
}

func (fake *FakeAuthService) Login(arg1 context.Context, arg2 string, arg3 string, arg4 string, arg5 string, arg6 string, arg7 string) (*domain.Session, *domain.User, error) {
	fake.loginMutex.Lock()
	ret, specificReturn := fake.loginReturnsOnCall[len(fake.loginArgsForCall)]
	fake.loginArgsForCall = append(fake.loginArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
		arg5 string
		arg6 string
		arg7 string
	}{arg1, arg2, arg3, arg4, arg5, arg6, arg7})
	stub := fake.LoginStub
	fakeReturns := fake.loginReturns
	fake.recordInvocation("Login", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6, arg7})
	fake.loginMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5, arg6, arg7)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeAuthService) LoginCallCount() int {
	fake.loginMutex.RLock()
	defer fake.loginMutex.RUnlock()
	return len(fake.loginArgsForCall)
}

func (fake *FakeAuthService) LoginCalls(stub func(context.Context, string, string, string, string, string, string) (*domain.Session, *domain.User, error)) {
	fake.loginMutex.Lock()
	defer fake.loginMutex.Unlock()
	fake.LoginStub = stub
}

func (fake *FakeAuthService) LoginArgsForCall(i int) (context.Context, string, string, string, string, string, string) {
	fake.loginMutex.RLock()
	defer fake.loginMutex.RUnlock()
	argsForCall := fake.loginArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6, argsForCall.arg7
}

func (fake *FakeAuthService) LoginReturns(result1 *domain.Session, result2 *domain.User, result3 error) {
	fake.loginMutex.Lock()
	defer fake.loginMutex.Unlock()
	fake.LoginStub = nil
	fake.loginReturns = struct {
		result1 *domain.Session
		result2 *domain.User
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeAuthService) LoginReturnsOnCall(i int, result1 *domain.Session, result2 *domain.User, result3 error) {
	fake.loginMutex.Lock()
	defer fake.loginMutex.Unlock()
	fake.LoginStub = nil
	if fake.loginReturnsOnCall == nil {
		fake.loginReturnsOnCall = make(map[int]struct {
			result1 *domain.Session
			result2 *domain.User
			result3 error
		})
	}
	fake.loginReturnsOnCall[i] = struct {
		result1 *domain.Session
		result2 *domain.User
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeAuthService) Logout(arg1 context.Context, arg2 uuid.UUID) error {
	fake.logoutMutex.Lock()
	ret, specificReturn := fake.logoutReturnsOnCall[len(fake.logoutArgsForCall)]
	fake.logoutArgsForCall = append(fake.logoutArgsForCall, struct {
		arg1 context.Context
		arg2 uuid.UUID
	}{arg1, arg2})
	stub := fake.LogoutStub
	fakeReturns := fake.logoutReturns
	fake.recordInvocation("Logout", []interface{}{arg1, arg2})
	fake.logoutMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeAuthService) LogoutCallCount() int {
	fake.logoutMutex.RLock()
	defer fake.logoutMutex.RUnlock()
	return len(fake.logoutArgsForCall)
}

func (fake *FakeAuthService) LogoutCalls(stub func(context.Context, uuid.UUID) error) {
	fake.logoutMutex.Lock()
	defer fake.logoutMutex.Unlock()
	fake.LogoutStub = stub
}

func (fake *FakeAuthService) LogoutArgsForCall(i int) (context.Context, uuid.UUID) {
	fake.logoutMutex.RLock()
	defer fake.logoutMutex.RUnlock()
	argsForCall := fake.logoutArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeAuthService) LogoutReturns(result1 error) {
	fake.logoutMutex.Lock()
	defer fake.logoutMutex.Unlock()
	fake.LogoutStub = nil
	fake.logoutReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeAuthService) LogoutReturnsOnCall(i int, result1 error) {
	fake.logoutMutex.Lock()
	defer fake.logoutMutex.Unlock()
	fake.LogoutStub = nil
	if fake.logoutReturnsOnCall == nil {
		fake.logoutReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.logoutReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeAuthService) RefreshToken(arg1 context.Context, arg2 string, arg3 string, arg4 string) (*domain.Session, string, error) {
	fake.refreshTokenMutex.Lock()
	ret, specificReturn := fake.refreshTokenReturnsOnCall[len(fake.refreshTokenArgsForCall)]
	fake.refreshTokenArgsForCall = append(fake.refreshTokenArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.RefreshTokenStub
	fakeReturns := fake.refreshTokenReturns
	fake.recordInvocation("RefreshToken", []interface{}{arg1, arg2, arg3, arg4})
	fake.refreshTokenMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeAuthService) RefreshTokenCallCount() int {
	fake.refreshTokenMutex.RLock()
	defer fake.refreshTokenMutex.RUnlock()
	return len(fake.refreshTokenArgsForCall)
}

func (fake *FakeAuthService) RefreshTokenCalls(stub func(context.Context, string, string, string) (*domain.Session, string, error)) {
	fake.refreshTokenMutex.Lock()
	defer fake.refreshTokenMutex.Unlock()
	fake.RefreshTokenStub = stub
}

func (fake *FakeAuthService) RefreshTokenArgsForCall(i int) (context.Context, string, string, string) {
	fake.refreshTokenMutex.RLock()
	defer fake.refreshTokenMutex.RUnlock()
	argsForCall := fake.refreshTokenArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeAuthService) RefreshTokenReturns(result1 *domain.Session, result2 string, result3 error) {
	fake.refreshTokenMutex.Lock()
	defer fake.refreshTokenMutex.Unlock()
	fake.RefreshTokenStub = nil
	fake.refreshTokenReturns = struct {
		result1 *domain.Session
		result2 string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeAuthService) RefreshTokenReturnsOnCall(i int, result1 *domain.Session, result2 string, result3 error) {
	fake.refreshTokenMutex.Lock()
	defer fake.refreshTokenMutex.Unlock()
	fake.RefreshTokenStub = nil
	if fake.refreshTokenReturnsOnCall == nil {
		fake.refreshTokenReturnsOnCall = make(map[int]struct {
			result1 *domain.Session
			result2 string
			result3 error
		})
	}
	fake.refreshTokenReturnsOnCall[i] = struct {
		result1 *domain.Session
		result2 string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeAuthService) RegisterAddressDetails(arg1 context.Context, arg2 domain.User) (*domain.User, error) {
	fake.registerAddressDetailsMutex.Lock()
	ret, specificReturn := fake.registerAddressDetailsReturnsOnCall[len(fake.registerAddressDetailsArgsForCall)]
	fake.registerAddressDetailsArgsForCall = append(fake.registerAddressDetailsArgsForCall, struct {
		arg1 context.Context
		arg2 domain.User
	}{arg1, arg2})
	stub := fake.RegisterAddressDetailsStub
	fakeReturns := fake.registerAddressDetailsReturns
	fake.recordInvocation("RegisterAddressDetails", []interface{}{arg1, arg2})
	fake.registerAddressDetailsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAuthService) RegisterAddressDetailsCallCount() int {
	fake.registerAddressDetailsMutex.RLock()
	defer fake.registerAddressDetailsMutex.RUnlock()
	return len(fake.registerAddressDetailsArgsForCall)
}

func (fake *FakeAuthService) RegisterAddressDetailsCalls(stub func(context.Context, domain.User) (*domain.User, error)) {
	fake.registerAddressDetailsMutex.Lock()
	defer fake.registerAddressDetailsMutex.Unlock()
	fake.RegisterAddressDetailsStub = stub
}

func (fake *FakeAuthService) RegisterAddressDetailsArgsForCall(i int) (context.Context, domain.User) {
	fake.registerAddressDetailsMutex.RLock()
	defer fake.registerAddressDetailsMutex.RUnlock()
	argsForCall := fake.registerAddressDetailsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeAuthService) RegisterAddressDetailsReturns(result1 *domain.User, result2 error) {
	fake.registerAddressDetailsMutex.Lock()
	defer fake.registerAddressDetailsMutex.Unlock()
	fake.RegisterAddressDetailsStub = nil
	fake.registerAddressDetailsReturns = struct {
		result1 *domain.User
		result2 error
	}{result1, result2}
}

func (fake *FakeAuthService) RegisterAddressDetailsReturnsOnCall(i int, result1 *domain.User, result2 error) {
	fake.registerAddressDetailsMutex.Lock()
	defer fake.registerAddressDetailsMutex.Unlock()
	fake.RegisterAddressDetailsStub = nil
	if fake.registerAddressDetailsReturnsOnCall == nil {
		fake.registerAddressDetailsReturnsOnCall = make(map[int]struct {
			result1 *domain.User
			result2 error
		})
	}
	fake.registerAddressDetailsReturnsOnCall[i] = struct {
		result1 *domain.User
		result2 error
	}{result1, result2}
}

func (fake *FakeAuthService) RegisterBusiness(arg1 context.Context, arg2 domain.User) (*domain.User, error) {
	fake.registerBusinessMutex.Lock()
	ret, specificReturn := fake.registerBusinessReturnsOnCall[len(fake.registerBusinessArgsForCall)]
	fake.registerBusinessArgsForCall = append(fake.registerBusinessArgsForCall, struct {
		arg1 context.Context
		arg2 domain.User
	}{arg1, arg2})
	stub := fake.RegisterBusinessStub
	fakeReturns := fake.registerBusinessReturns
	fake.recordInvocation("RegisterBusiness", []interface{}{arg1, arg2})
	fake.registerBusinessMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAuthService) RegisterBusinessCallCount() int {
	fake.registerBusinessMutex.RLock()
	defer fake.registerBusinessMutex.RUnlock()
	return len(fake.registerBusinessArgsForCall)
}

func (fake *FakeAuthService) RegisterBusinessCalls(stub func(context.Context, domain.User) (*domain.User, error)) {
	fake.registerBusinessMutex.Lock()
	defer fake.registerBusinessMutex.Unlock()
	fake.RegisterBusinessStub = stub
}

func (fake *FakeAuthService) RegisterBusinessArgsForCall(i int) (context.Context, domain.User) {
	fake.registerBusinessMutex.RLock()
	defer fake.registerBusinessMutex.RUnlock()
	argsForCall := fake.registerBusinessArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeAuthService) RegisterBusinessReturns(result1 *domain.User, result2 error) {
	fake.registerBusinessMutex.Lock()
	defer fake.registerBusinessMutex.Unlock()
	fake.RegisterBusinessStub = nil
	fake.registerBusinessReturns = struct {
		result1 *domain.User
		result2 error
	}{result1, result2}
}

func (fake *FakeAuthService) RegisterBusinessReturnsOnCall(i int, result1 *domain.User, result2 error) {
	fake.registerBusinessMutex.Lock()
	defer fake.registerBusinessMutex.Unlock()
	fake.RegisterBusinessStub = nil
	if fake.registerBusinessReturnsOnCall == nil {
		fake.registerBusinessReturnsOnCall = make(map[int]struct {
			result1 *domain.User
			result2 error
		})
	}
	fake.registerBusinessReturnsOnCall[i] = struct {
		result1 *domain.User
		result2 error
	}{result1, result2}
}

func (fake *FakeAuthService) RegisterBusinessDetails(arg1 context.Context, arg2 domain.User) (*domain.User, error) {
	fake.registerBusinessDetailsMutex.Lock()
	ret, specificReturn := fake.registerBusinessDetailsReturnsOnCall[len(fake.registerBusinessDetailsArgsForCall)]
	fake.registerBusinessDetailsArgsForCall = append(fake.registerBusinessDetailsArgsForCall, struct {
		arg1 context.Context
		arg2 domain.User
	}{arg1, arg2})
	stub := fake.RegisterBusinessDetailsStub
	fakeReturns := fake.registerBusinessDetailsReturns
	fake.recordInvocation("RegisterBusinessDetails", []interface{}{arg1, arg2})
	fake.registerBusinessDetailsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAuthService) RegisterBusinessDetailsCallCount() int {
	fake.registerBusinessDetailsMutex.RLock()
	defer fake.registerBusinessDetailsMutex.RUnlock()
	return len(fake.registerBusinessDetailsArgsForCall)
}

func (fake *FakeAuthService) RegisterBusinessDetailsCalls(stub func(context.Context, domain.User) (*domain.User, error)) {
	fake.registerBusinessDetailsMutex.Lock()
	defer fake.registerBusinessDetailsMutex.Unlock()
	fake.RegisterBusinessDetailsStub = stub
}

func (fake *FakeAuthService) RegisterBusinessDetailsArgsForCall(i int) (context.Context, domain.User) {
	fake.registerBusinessDetailsMutex.RLock()
	defer fake.registerBusinessDetailsMutex.RUnlock()
	argsForCall := fake.registerBusinessDetailsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeAuthService) RegisterBusinessDetailsReturns(result1 *domain.User, result2 error) {
	fake.registerBusinessDetailsMutex.Lock()
	defer fake.registerBusinessDetailsMutex.Unlock()
	fake.RegisterBusinessDetailsStub = nil
	fake.registerBusinessDetailsReturns = struct {
		result1 *domain.User
		result2 error
	}{result1, result2}
}

func (fake *FakeAuthService) RegisterBusinessDetailsReturnsOnCall(i int, result1 *domain.User, result2 error) {
	fake.registerBusinessDetailsMutex.Lock()
	defer fake.registerBusinessDetailsMutex.Unlock()
	fake.RegisterBusinessDetailsStub = nil
	if fake.registerBusinessDetailsReturnsOnCall == nil {
		fake.registerBusinessDetailsReturnsOnCall = make(map[int]struct {
			result1 *domain.User
			result2 error
		})
	}
	fake.registerBusinessDetailsReturnsOnCall[i] = struct {
		result1 *domain.User
		result2 error
	}{result1, result2}
}

func (fake *FakeAuthService) RegisterPersonalDetails(arg1 context.Context, arg2 domain.User) (*domain.User, error) {
	fake.registerPersonalDetailsMutex.Lock()
	ret, specificReturn := fake.registerPersonalDetailsReturnsOnCall[len(fake.registerPersonalDetailsArgsForCall)]
	fake.registerPersonalDetailsArgsForCall = append(fake.registerPersonalDetailsArgsForCall, struct {
		arg1 context.Context
		arg2 domain.User
	}{arg1, arg2})
	stub := fake.RegisterPersonalDetailsStub
	fakeReturns := fake.registerPersonalDetailsReturns
	fake.recordInvocation("RegisterPersonalDetails", []interface{}{arg1, arg2})
	fake.registerPersonalDetailsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAuthService) RegisterPersonalDetailsCallCount() int {
	fake.registerPersonalDetailsMutex.RLock()
	defer fake.registerPersonalDetailsMutex.RUnlock()
	return len(fake.registerPersonalDetailsArgsForCall)
}

func (fake *FakeAuthService) RegisterPersonalDetailsCalls(stub func(context.Context, domain.User) (*domain.User, error)) {
	fake.registerPersonalDetailsMutex.Lock()
	defer fake.registerPersonalDetailsMutex.Unlock()
	fake.RegisterPersonalDetailsStub = stub
}

func (fake *FakeAuthService) RegisterPersonalDetailsArgsForCall(i int) (context.Context, domain.User) {
	fake.registerPersonalDetailsMutex.RLock()
	defer fake.registerPersonalDetailsMutex.RUnlock()
	argsForCall := fake.registerPersonalDetailsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeAuthService) RegisterPersonalDetailsReturns(result1 *domain.User, result2 error) {
	fake.registerPersonalDetailsMutex.Lock()
	defer fake.registerPersonalDetailsMutex.Unlock()
	fake.RegisterPersonalDetailsStub = nil
	fake.registerPersonalDetailsReturns = struct {
		result1 *domain.User
		result2 error
	}{result1, result2}
}

func (fake *FakeAuthService) RegisterPersonalDetailsReturnsOnCall(i int, result1 *domain.User, result2 error) {
	fake.registerPersonalDetailsMutex.Lock()
	defer fake.registerPersonalDetailsMutex.Unlock()
	fake.RegisterPersonalDetailsStub = nil
	if fake.registerPersonalDetailsReturnsOnCall == nil {
		fake.registerPersonalDetailsReturnsOnCall = make(map[int]struct {
			result1 *domain.User
			result2 error
		})
	}
	fake.registerPersonalDetailsReturnsOnCall[i] = struct {
		result1 *domain.User
		result2 error
	}{result1, result2}
}

func (fake *FakeAuthService) RegisterUser(arg1 context.Context, arg2 domain.User, arg3 string) (*domain.User, error) {
	fake.registerUserMutex.Lock()
	ret, specificReturn := fake.registerUserReturnsOnCall[len(fake.registerUserArgsForCall)]
	fake.registerUserArgsForCall = append(fake.registerUserArgsForCall, struct {
		arg1 context.Context
		arg2 domain.User
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.RegisterUserStub
	fakeReturns := fake.registerUserReturns
	fake.recordInvocation("RegisterUser", []interface{}{arg1, arg2, arg3})
	fake.registerUserMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAuthService) RegisterUserCallCount() int {
	fake.registerUserMutex.RLock()
	defer fake.registerUserMutex.RUnlock()
	return len(fake.registerUserArgsForCall)
}

func (fake *FakeAuthService) RegisterUserCalls(stub func(context.Context, domain.User, string) (*domain.User, error)) {
	fake.registerUserMutex.Lock()
	defer fake.registerUserMutex.Unlock()
	fake.RegisterUserStub = stub
}

func (fake *FakeAuthService) RegisterUserArgsForCall(i int) (context.Context, domain.User, string) {
	fake.registerUserMutex.RLock()
	defer fake.registerUserMutex.RUnlock()
	argsForCall := fake.registerUserArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeAuthService) RegisterUserReturns(result1 *domain.User, result2 error) {
	fake.registerUserMutex.Lock()
	defer fake.registerUserMutex.Unlock()
	fake.RegisterUserStub = nil
	fake.registerUserReturns = struct {
		result1 *domain.User
		result2 error
	}{result1, result2}
}

func (fake *FakeAuthService) RegisterUserReturnsOnCall(i int, result1 *domain.User, result2 error) {
	fake.registerUserMutex.Lock()
	defer fake.registerUserMutex.Unlock()
	fake.RegisterUserStub = nil
	if fake.registerUserReturnsOnCall == nil {
		fake.registerUserReturnsOnCall = make(map[int]struct {
			result1 *domain.User
			result2 error
		})
	}
	fake.registerUserReturnsOnCall[i] = struct {
		result1 *domain.User
		result2 error
	}{result1, result2}
}

func (fake *FakeAuthService) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.checkEmailExistsMutex.RLock()
	defer fake.checkEmailExistsMutex.RUnlock()
	fake.createSessionMutex.RLock()
	defer fake.createSessionMutex.RUnlock()
	fake.getUserByEmailMutex.RLock()
	defer fake.getUserByEmailMutex.RUnlock()
	fake.getUserByIDMutex.RLock()
	defer fake.getUserByIDMutex.RUnlock()
	fake.loginMutex.RLock()
	defer fake.loginMutex.RUnlock()
	fake.logoutMutex.RLock()
	defer fake.logoutMutex.RUnlock()
	fake.refreshTokenMutex.RLock()
	defer fake.refreshTokenMutex.RUnlock()
	fake.registerAddressDetailsMutex.RLock()
	defer fake.registerAddressDetailsMutex.RUnlock()
	fake.registerBusinessMutex.RLock()
	defer fake.registerBusinessMutex.RUnlock()
	fake.registerBusinessDetailsMutex.RLock()
	defer fake.registerBusinessDetailsMutex.RUnlock()
	fake.registerPersonalDetailsMutex.RLock()
	defer fake.registerPersonalDetailsMutex.RUnlock()
	fake.registerUserMutex.RLock()
	defer fake.registerUserMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeAuthService) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ ports.AuthService = new(FakeAuthService)
