// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"context"
	"sync"

	"github.com/demola234/defifundr/internal/core/domain"
	"github.com/demola234/defifundr/internal/core/ports"
	"github.com/google/uuid"
)

type FakeOTPRepository struct {
	CreateOTPStub        func(context.Context, domain.OTPVerification) (*domain.OTPVerification, error)
	createOTPMutex       sync.RWMutex
	createOTPArgsForCall []struct {
		arg1 context.Context
		arg2 domain.OTPVerification
	}
	createOTPReturns struct {
		result1 *domain.OTPVerification
		result2 error
	}
	createOTPReturnsOnCall map[int]struct {
		result1 *domain.OTPVerification
		result2 error
	}
	GetOTPByUserIDAndPurposeStub        func(context.Context, uuid.UUID, domain.OTPPurpose) (*domain.OTPVerification, error)
	getOTPByUserIDAndPurposeMutex       sync.RWMutex
	getOTPByUserIDAndPurposeArgsForCall []struct {
		arg1 context.Context
		arg2 uuid.UUID
		arg3 domain.OTPPurpose
	}
	getOTPByUserIDAndPurposeReturns struct {
		result1 *domain.OTPVerification
		result2 error
	}
	getOTPByUserIDAndPurposeReturnsOnCall map[int]struct {
		result1 *domain.OTPVerification
		result2 error
	}
	IncrementAttemptsStub        func(context.Context, uuid.UUID) error
	incrementAttemptsMutex       sync.RWMutex
	incrementAttemptsArgsForCall []struct {
		arg1 context.Context
		arg2 uuid.UUID
	}
	incrementAttemptsReturns struct {
		result1 error
	}
	incrementAttemptsReturnsOnCall map[int]struct {
		result1 error
	}
	VerifyOTPStub        func(context.Context, uuid.UUID, string) error
	verifyOTPMutex       sync.RWMutex
	verifyOTPArgsForCall []struct {
		arg1 context.Context
		arg2 uuid.UUID
		arg3 string
	}
	verifyOTPReturns struct {
		result1 error
	}
	verifyOTPReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeOTPRepository) CreateOTP(arg1 context.Context, arg2 domain.OTPVerification) (*domain.OTPVerification, error) {
	fake.createOTPMutex.Lock()
	ret, specificReturn := fake.createOTPReturnsOnCall[len(fake.createOTPArgsForCall)]
	fake.createOTPArgsForCall = append(fake.createOTPArgsForCall, struct {
		arg1 context.Context
		arg2 domain.OTPVerification
	}{arg1, arg2})
	stub := fake.CreateOTPStub
	fakeReturns := fake.createOTPReturns
	fake.recordInvocation("CreateOTP", []interface{}{arg1, arg2})
	fake.createOTPMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeOTPRepository) CreateOTPCallCount() int {
	fake.createOTPMutex.RLock()
	defer fake.createOTPMutex.RUnlock()
	return len(fake.createOTPArgsForCall)
}

func (fake *FakeOTPRepository) CreateOTPCalls(stub func(context.Context, domain.OTPVerification) (*domain.OTPVerification, error)) {
	fake.createOTPMutex.Lock()
	defer fake.createOTPMutex.Unlock()
	fake.CreateOTPStub = stub
}

func (fake *FakeOTPRepository) CreateOTPArgsForCall(i int) (context.Context, domain.OTPVerification) {
	fake.createOTPMutex.RLock()
	defer fake.createOTPMutex.RUnlock()
	argsForCall := fake.createOTPArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeOTPRepository) CreateOTPReturns(result1 *domain.OTPVerification, result2 error) {
	fake.createOTPMutex.Lock()
	defer fake.createOTPMutex.Unlock()
	fake.CreateOTPStub = nil
	fake.createOTPReturns = struct {
		result1 *domain.OTPVerification
		result2 error
	}{result1, result2}
}

func (fake *FakeOTPRepository) CreateOTPReturnsOnCall(i int, result1 *domain.OTPVerification, result2 error) {
	fake.createOTPMutex.Lock()
	defer fake.createOTPMutex.Unlock()
	fake.CreateOTPStub = nil
	if fake.createOTPReturnsOnCall == nil {
		fake.createOTPReturnsOnCall = make(map[int]struct {
			result1 *domain.OTPVerification
			result2 error
		})
	}
	fake.createOTPReturnsOnCall[i] = struct {
		result1 *domain.OTPVerification
		result2 error
	}{result1, result2}
}

func (fake *FakeOTPRepository) GetOTPByUserIDAndPurpose(arg1 context.Context, arg2 uuid.UUID, arg3 domain.OTPPurpose) (*domain.OTPVerification, error) {
	fake.getOTPByUserIDAndPurposeMutex.Lock()
	ret, specificReturn := fake.getOTPByUserIDAndPurposeReturnsOnCall[len(fake.getOTPByUserIDAndPurposeArgsForCall)]
	fake.getOTPByUserIDAndPurposeArgsForCall = append(fake.getOTPByUserIDAndPurposeArgsForCall, struct {
		arg1 context.Context
		arg2 uuid.UUID
		arg3 domain.OTPPurpose
	}{arg1, arg2, arg3})
	stub := fake.GetOTPByUserIDAndPurposeStub
	fakeReturns := fake.getOTPByUserIDAndPurposeReturns
	fake.recordInvocation("GetOTPByUserIDAndPurpose", []interface{}{arg1, arg2, arg3})
	fake.getOTPByUserIDAndPurposeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeOTPRepository) GetOTPByUserIDAndPurposeCallCount() int {
	fake.getOTPByUserIDAndPurposeMutex.RLock()
	defer fake.getOTPByUserIDAndPurposeMutex.RUnlock()
	return len(fake.getOTPByUserIDAndPurposeArgsForCall)
}

func (fake *FakeOTPRepository) GetOTPByUserIDAndPurposeCalls(stub func(context.Context, uuid.UUID, domain.OTPPurpose) (*domain.OTPVerification, error)) {
	fake.getOTPByUserIDAndPurposeMutex.Lock()
	defer fake.getOTPByUserIDAndPurposeMutex.Unlock()
	fake.GetOTPByUserIDAndPurposeStub = stub
}

func (fake *FakeOTPRepository) GetOTPByUserIDAndPurposeArgsForCall(i int) (context.Context, uuid.UUID, domain.OTPPurpose) {
	fake.getOTPByUserIDAndPurposeMutex.RLock()
	defer fake.getOTPByUserIDAndPurposeMutex.RUnlock()
	argsForCall := fake.getOTPByUserIDAndPurposeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeOTPRepository) GetOTPByUserIDAndPurposeReturns(result1 *domain.OTPVerification, result2 error) {
	fake.getOTPByUserIDAndPurposeMutex.Lock()
	defer fake.getOTPByUserIDAndPurposeMutex.Unlock()
	fake.GetOTPByUserIDAndPurposeStub = nil
	fake.getOTPByUserIDAndPurposeReturns = struct {
		result1 *domain.OTPVerification
		result2 error
	}{result1, result2}
}

func (fake *FakeOTPRepository) GetOTPByUserIDAndPurposeReturnsOnCall(i int, result1 *domain.OTPVerification, result2 error) {
	fake.getOTPByUserIDAndPurposeMutex.Lock()
	defer fake.getOTPByUserIDAndPurposeMutex.Unlock()
	fake.GetOTPByUserIDAndPurposeStub = nil
	if fake.getOTPByUserIDAndPurposeReturnsOnCall == nil {
		fake.getOTPByUserIDAndPurposeReturnsOnCall = make(map[int]struct {
			result1 *domain.OTPVerification
			result2 error
		})
	}
	fake.getOTPByUserIDAndPurposeReturnsOnCall[i] = struct {
		result1 *domain.OTPVerification
		result2 error
	}{result1, result2}
}

func (fake *FakeOTPRepository) IncrementAttempts(arg1 context.Context, arg2 uuid.UUID) error {
	fake.incrementAttemptsMutex.Lock()
	ret, specificReturn := fake.incrementAttemptsReturnsOnCall[len(fake.incrementAttemptsArgsForCall)]
	fake.incrementAttemptsArgsForCall = append(fake.incrementAttemptsArgsForCall, struct {
		arg1 context.Context
		arg2 uuid.UUID
	}{arg1, arg2})
	stub := fake.IncrementAttemptsStub
	fakeReturns := fake.incrementAttemptsReturns
	fake.recordInvocation("IncrementAttempts", []interface{}{arg1, arg2})
	fake.incrementAttemptsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeOTPRepository) IncrementAttemptsCallCount() int {
	fake.incrementAttemptsMutex.RLock()
	defer fake.incrementAttemptsMutex.RUnlock()
	return len(fake.incrementAttemptsArgsForCall)
}

func (fake *FakeOTPRepository) IncrementAttemptsCalls(stub func(context.Context, uuid.UUID) error) {
	fake.incrementAttemptsMutex.Lock()
	defer fake.incrementAttemptsMutex.Unlock()
	fake.IncrementAttemptsStub = stub
}

func (fake *FakeOTPRepository) IncrementAttemptsArgsForCall(i int) (context.Context, uuid.UUID) {
	fake.incrementAttemptsMutex.RLock()
	defer fake.incrementAttemptsMutex.RUnlock()
	argsForCall := fake.incrementAttemptsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeOTPRepository) IncrementAttemptsReturns(result1 error) {
	fake.incrementAttemptsMutex.Lock()
	defer fake.incrementAttemptsMutex.Unlock()
	fake.IncrementAttemptsStub = nil
	fake.incrementAttemptsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeOTPRepository) IncrementAttemptsReturnsOnCall(i int, result1 error) {
	fake.incrementAttemptsMutex.Lock()
	defer fake.incrementAttemptsMutex.Unlock()
	fake.IncrementAttemptsStub = nil
	if fake.incrementAttemptsReturnsOnCall == nil {
		fake.incrementAttemptsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.incrementAttemptsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeOTPRepository) VerifyOTP(arg1 context.Context, arg2 uuid.UUID, arg3 string) error {
	fake.verifyOTPMutex.Lock()
	ret, specificReturn := fake.verifyOTPReturnsOnCall[len(fake.verifyOTPArgsForCall)]
	fake.verifyOTPArgsForCall = append(fake.verifyOTPArgsForCall, struct {
		arg1 context.Context
		arg2 uuid.UUID
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.VerifyOTPStub
	fakeReturns := fake.verifyOTPReturns
	fake.recordInvocation("VerifyOTP", []interface{}{arg1, arg2, arg3})
	fake.verifyOTPMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeOTPRepository) VerifyOTPCallCount() int {
	fake.verifyOTPMutex.RLock()
	defer fake.verifyOTPMutex.RUnlock()
	return len(fake.verifyOTPArgsForCall)
}

func (fake *FakeOTPRepository) VerifyOTPCalls(stub func(context.Context, uuid.UUID, string) error) {
	fake.verifyOTPMutex.Lock()
	defer fake.verifyOTPMutex.Unlock()
	fake.VerifyOTPStub = stub
}

func (fake *FakeOTPRepository) VerifyOTPArgsForCall(i int) (context.Context, uuid.UUID, string) {
	fake.verifyOTPMutex.RLock()
	defer fake.verifyOTPMutex.RUnlock()
	argsForCall := fake.verifyOTPArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeOTPRepository) VerifyOTPReturns(result1 error) {
	fake.verifyOTPMutex.Lock()
	defer fake.verifyOTPMutex.Unlock()
	fake.VerifyOTPStub = nil
	fake.verifyOTPReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeOTPRepository) VerifyOTPReturnsOnCall(i int, result1 error) {
	fake.verifyOTPMutex.Lock()
	defer fake.verifyOTPMutex.Unlock()
	fake.VerifyOTPStub = nil
	if fake.verifyOTPReturnsOnCall == nil {
		fake.verifyOTPReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.verifyOTPReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeOTPRepository) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createOTPMutex.RLock()
	defer fake.createOTPMutex.RUnlock()
	fake.getOTPByUserIDAndPurposeMutex.RLock()
	defer fake.getOTPByUserIDAndPurposeMutex.RUnlock()
	fake.incrementAttemptsMutex.RLock()
	defer fake.incrementAttemptsMutex.RUnlock()
	fake.verifyOTPMutex.RLock()
	defer fake.verifyOTPMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeOTPRepository) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ ports.OTPRepository = new(FakeOTPRepository)
