// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: payroll_employees.sql

package sqlc

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const addPayrollEmployee = `-- name: AddPayrollEmployee :one
INSERT INTO payroll_employees (
  payroll_id,
  employee_id
) VALUES (
  $1, $2
) RETURNING id, payroll_id, employee_id, created_at
`

type AddPayrollEmployeeParams struct {
	PayrollID  uuid.UUID `json:"payroll_id"`
	EmployeeID uuid.UUID `json:"employee_id"`
}

func (q *Queries) AddPayrollEmployee(ctx context.Context, arg AddPayrollEmployeeParams) (PayrollEmployees, error) {
	row := q.db.QueryRow(ctx, addPayrollEmployee, arg.PayrollID, arg.EmployeeID)
	var i PayrollEmployees
	err := row.Scan(
		&i.ID,
		&i.PayrollID,
		&i.EmployeeID,
		&i.CreatedAt,
	)
	return i, err
}

const getPayrollEmployee = `-- name: GetPayrollEmployee :one
SELECT id, payroll_id, employee_id, created_at FROM payroll_employees
WHERE payroll_id = $1 AND employee_id = $2
LIMIT 1
`

type GetPayrollEmployeeParams struct {
	PayrollID  uuid.UUID `json:"payroll_id"`
	EmployeeID uuid.UUID `json:"employee_id"`
}

func (q *Queries) GetPayrollEmployee(ctx context.Context, arg GetPayrollEmployeeParams) (PayrollEmployees, error) {
	row := q.db.QueryRow(ctx, getPayrollEmployee, arg.PayrollID, arg.EmployeeID)
	var i PayrollEmployees
	err := row.Scan(
		&i.ID,
		&i.PayrollID,
		&i.EmployeeID,
		&i.CreatedAt,
	)
	return i, err
}

const listEmployeePayrolls = `-- name: ListEmployeePayrolls :many
SELECT p.id, p.employer_id, p.organization_id, p.payment_frequency, p.salary_amount, p.currency, p.contract_address, p.status, p.created_at, p.updated_at
FROM payrolls p
JOIN payroll_employees pe ON p.id = pe.payroll_id
WHERE pe.employee_id = $1
ORDER BY p.created_at DESC
`

func (q *Queries) ListEmployeePayrolls(ctx context.Context, employeeID uuid.UUID) ([]Payrolls, error) {
	rows, err := q.db.Query(ctx, listEmployeePayrolls, employeeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Payrolls{}
	for rows.Next() {
		var i Payrolls
		if err := rows.Scan(
			&i.ID,
			&i.EmployerID,
			&i.OrganizationID,
			&i.PaymentFrequency,
			&i.SalaryAmount,
			&i.Currency,
			&i.ContractAddress,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPayrollEmployees = `-- name: ListPayrollEmployees :many
SELECT pe.id, pe.payroll_id, pe.employee_id, pe.created_at, u.first_name, u.last_name, u.email
FROM payroll_employees pe
JOIN users u ON pe.employee_id = u.id
WHERE pe.payroll_id = $1
ORDER BY pe.created_at DESC
`

type ListPayrollEmployeesRow struct {
	ID         uuid.UUID `json:"id"`
	PayrollID  uuid.UUID `json:"payroll_id"`
	EmployeeID uuid.UUID `json:"employee_id"`
	CreatedAt  time.Time `json:"created_at"`
	FirstName  string    `json:"first_name"`
	LastName   string    `json:"last_name"`
	Email      string    `json:"email"`
}

func (q *Queries) ListPayrollEmployees(ctx context.Context, payrollID uuid.UUID) ([]ListPayrollEmployeesRow, error) {
	rows, err := q.db.Query(ctx, listPayrollEmployees, payrollID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPayrollEmployeesRow{}
	for rows.Next() {
		var i ListPayrollEmployeesRow
		if err := rows.Scan(
			&i.ID,
			&i.PayrollID,
			&i.EmployeeID,
			&i.CreatedAt,
			&i.FirstName,
			&i.LastName,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removePayrollEmployee = `-- name: RemovePayrollEmployee :exec
DELETE FROM payroll_employees
WHERE payroll_id = $1 AND employee_id = $2
`

type RemovePayrollEmployeeParams struct {
	PayrollID  uuid.UUID `json:"payroll_id"`
	EmployeeID uuid.UUID `json:"employee_id"`
}

func (q *Queries) RemovePayrollEmployee(ctx context.Context, arg RemovePayrollEmployeeParams) error {
	_, err := q.db.Exec(ctx, removePayrollEmployee, arg.PayrollID, arg.EmployeeID)
	return err
}
