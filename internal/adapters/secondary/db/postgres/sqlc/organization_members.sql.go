// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: organization_members.sql

package sqlc

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const addOrganizationMember = `-- name: AddOrganizationMember :one
INSERT INTO organization_members (
  organization_id,
  employee_id,
  role
) VALUES (
  $1, $2, $3
) RETURNING id, organization_id, employee_id, role, created_at
`

type AddOrganizationMemberParams struct {
	OrganizationID uuid.UUID `json:"organization_id"`
	EmployeeID     uuid.UUID `json:"employee_id"`
	Role           string    `json:"role"`
}

func (q *Queries) AddOrganizationMember(ctx context.Context, arg AddOrganizationMemberParams) (OrganizationMembers, error) {
	row := q.db.QueryRow(ctx, addOrganizationMember, arg.OrganizationID, arg.EmployeeID, arg.Role)
	var i OrganizationMembers
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.EmployeeID,
		&i.Role,
		&i.CreatedAt,
	)
	return i, err
}

const getOrganizationMember = `-- name: GetOrganizationMember :one
SELECT id, organization_id, employee_id, role, created_at FROM organization_members
WHERE organization_id = $1 AND employee_id = $2
LIMIT 1
`

type GetOrganizationMemberParams struct {
	OrganizationID uuid.UUID `json:"organization_id"`
	EmployeeID     uuid.UUID `json:"employee_id"`
}

func (q *Queries) GetOrganizationMember(ctx context.Context, arg GetOrganizationMemberParams) (OrganizationMembers, error) {
	row := q.db.QueryRow(ctx, getOrganizationMember, arg.OrganizationID, arg.EmployeeID)
	var i OrganizationMembers
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.EmployeeID,
		&i.Role,
		&i.CreatedAt,
	)
	return i, err
}

const listOrganizationMembers = `-- name: ListOrganizationMembers :many
SELECT om.id, om.organization_id, om.employee_id, om.role, om.created_at, u.first_name, u.last_name, u.email
FROM organization_members om
JOIN users u ON om.employee_id = u.id
WHERE om.organization_id = $1
ORDER BY om.created_at DESC
`

type ListOrganizationMembersRow struct {
	ID             uuid.UUID `json:"id"`
	OrganizationID uuid.UUID `json:"organization_id"`
	EmployeeID     uuid.UUID `json:"employee_id"`
	Role           string    `json:"role"`
	CreatedAt      time.Time `json:"created_at"`
	FirstName      string    `json:"first_name"`
	LastName       string    `json:"last_name"`
	Email          string    `json:"email"`
}

func (q *Queries) ListOrganizationMembers(ctx context.Context, organizationID uuid.UUID) ([]ListOrganizationMembersRow, error) {
	rows, err := q.db.Query(ctx, listOrganizationMembers, organizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListOrganizationMembersRow{}
	for rows.Next() {
		var i ListOrganizationMembersRow
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.EmployeeID,
			&i.Role,
			&i.CreatedAt,
			&i.FirstName,
			&i.LastName,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserOrganizationMemberships = `-- name: ListUserOrganizationMemberships :many
SELECT om.id, om.organization_id, om.employee_id, om.role, om.created_at, o.name as organization_name
FROM organization_members om
JOIN organizations o ON om.organization_id = o.id
WHERE om.employee_id = $1
ORDER BY om.created_at DESC
`

type ListUserOrganizationMembershipsRow struct {
	ID               uuid.UUID `json:"id"`
	OrganizationID   uuid.UUID `json:"organization_id"`
	EmployeeID       uuid.UUID `json:"employee_id"`
	Role             string    `json:"role"`
	CreatedAt        time.Time `json:"created_at"`
	OrganizationName string    `json:"organization_name"`
}

func (q *Queries) ListUserOrganizationMemberships(ctx context.Context, employeeID uuid.UUID) ([]ListUserOrganizationMembershipsRow, error) {
	rows, err := q.db.Query(ctx, listUserOrganizationMemberships, employeeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUserOrganizationMembershipsRow{}
	for rows.Next() {
		var i ListUserOrganizationMembershipsRow
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.EmployeeID,
			&i.Role,
			&i.CreatedAt,
			&i.OrganizationName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeOrganizationMember = `-- name: RemoveOrganizationMember :exec
DELETE FROM organization_members
WHERE organization_id = $1 AND employee_id = $2
`

type RemoveOrganizationMemberParams struct {
	OrganizationID uuid.UUID `json:"organization_id"`
	EmployeeID     uuid.UUID `json:"employee_id"`
}

func (q *Queries) RemoveOrganizationMember(ctx context.Context, arg RemoveOrganizationMemberParams) error {
	_, err := q.db.Exec(ctx, removeOrganizationMember, arg.OrganizationID, arg.EmployeeID)
	return err
}

const updateOrganizationMemberRole = `-- name: UpdateOrganizationMemberRole :one
UPDATE organization_members
SET role = $3
WHERE organization_id = $1 AND employee_id = $2
RETURNING id, organization_id, employee_id, role, created_at
`

type UpdateOrganizationMemberRoleParams struct {
	OrganizationID uuid.UUID `json:"organization_id"`
	EmployeeID     uuid.UUID `json:"employee_id"`
	Role           string    `json:"role"`
}

func (q *Queries) UpdateOrganizationMemberRole(ctx context.Context, arg UpdateOrganizationMemberRoleParams) (OrganizationMembers, error) {
	row := q.db.QueryRow(ctx, updateOrganizationMemberRole, arg.OrganizationID, arg.EmployeeID, arg.Role)
	var i OrganizationMembers
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.EmployeeID,
		&i.Role,
		&i.CreatedAt,
	)
	return i, err
}
