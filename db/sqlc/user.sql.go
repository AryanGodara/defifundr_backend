// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.17.2
// source: user.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const changePassword = `-- name: ChangePassword :one
UPDATE users
SET
    hashed_password = $2,
    password_changed_at = $3
WHERE username = $1 RETURNING username, hashed_password, avatar, email, is_email_verified, password_changed_at, balance, address, file_path, secret_code, is_used, created_at, expired_at
`

type ChangePasswordParams struct {
	Username          string    `json:"username"`
	HashedPassword    string    `json:"hashed_password"`
	PasswordChangedAt time.Time `json:"password_changed_at"`
}

func (q *Queries) ChangePassword(ctx context.Context, arg ChangePasswordParams) (Users, error) {
	row := q.db.QueryRowContext(ctx, changePassword, arg.Username, arg.HashedPassword, arg.PasswordChangedAt)
	var i Users
	err := row.Scan(
		&i.Username,
		&i.HashedPassword,
		&i.Avatar,
		&i.Email,
		&i.IsEmailVerified,
		&i.PasswordChangedAt,
		&i.Balance,
		&i.Address,
		&i.FilePath,
		&i.SecretCode,
		&i.IsUsed,
		&i.CreatedAt,
		&i.ExpiredAt,
	)
	return i, err
}

const checkUsernameExists = `-- name: CheckUsernameExists :one

SELECT EXISTS (
        SELECT 1
        FROM users
        WHERE username = $1
        LIMIT 1
    )
`

func (q *Queries) CheckUsernameExists(ctx context.Context, username string) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkUsernameExists, username)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createUser = `-- name: CreateUser :one

INSERT INTO
    users (
        hashed_password,
        username,
        avatar,
        email,
        balance,
        address,
        file_path,
        secret_code,
        is_used,
        is_email_verified
    )
VALUES (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7,
        $8,
        $9,
        $10
    ) RETURNING username, hashed_password, avatar, email, is_email_verified, password_changed_at, balance, address, file_path, secret_code, is_used, created_at, expired_at
`

type CreateUserParams struct {
	HashedPassword  string `json:"hashed_password"`
	Username        string `json:"username"`
	Avatar          string `json:"avatar"`
	Email           string `json:"email"`
	Balance         int64  `json:"balance"`
	Address         string `json:"address"`
	FilePath        string `json:"file_path"`
	SecretCode      string `json:"secret_code"`
	IsUsed          bool   `json:"is_used"`
	IsEmailVerified bool   `json:"is_email_verified"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (Users, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.HashedPassword,
		arg.Username,
		arg.Avatar,
		arg.Email,
		arg.Balance,
		arg.Address,
		arg.FilePath,
		arg.SecretCode,
		arg.IsUsed,
		arg.IsEmailVerified,
	)
	var i Users
	err := row.Scan(
		&i.Username,
		&i.HashedPassword,
		&i.Avatar,
		&i.Email,
		&i.IsEmailVerified,
		&i.PasswordChangedAt,
		&i.Balance,
		&i.Address,
		&i.FilePath,
		&i.SecretCode,
		&i.IsUsed,
		&i.CreatedAt,
		&i.ExpiredAt,
	)
	return i, err
}

const deleteUser = `-- name: DeleteUser :one

DELETE FROM users WHERE username = $1 RETURNING username, hashed_password, avatar, email, is_email_verified, password_changed_at, balance, address, file_path, secret_code, is_used, created_at, expired_at
`

func (q *Queries) DeleteUser(ctx context.Context, username string) (Users, error) {
	row := q.db.QueryRowContext(ctx, deleteUser, username)
	var i Users
	err := row.Scan(
		&i.Username,
		&i.HashedPassword,
		&i.Avatar,
		&i.Email,
		&i.IsEmailVerified,
		&i.PasswordChangedAt,
		&i.Balance,
		&i.Address,
		&i.FilePath,
		&i.SecretCode,
		&i.IsUsed,
		&i.CreatedAt,
		&i.ExpiredAt,
	)
	return i, err
}

const getUser = `-- name: GetUser :one

SELECT username, hashed_password, avatar, email, is_email_verified, password_changed_at, balance, address, file_path, secret_code, is_used, created_at, expired_at FROM users WHERE username = $1 OR email = $1 LIMIT 1
`

func (q *Queries) GetUser(ctx context.Context, username string) (Users, error) {
	row := q.db.QueryRowContext(ctx, getUser, username)
	var i Users
	err := row.Scan(
		&i.Username,
		&i.HashedPassword,
		&i.Avatar,
		&i.Email,
		&i.IsEmailVerified,
		&i.PasswordChangedAt,
		&i.Balance,
		&i.Address,
		&i.FilePath,
		&i.SecretCode,
		&i.IsUsed,
		&i.CreatedAt,
		&i.ExpiredAt,
	)
	return i, err
}

const updateUser = `-- name: UpdateUser :one

UPDATE users
SET
    hashed_password = COALESCE(
        $1,
        hashed_password
    ),
    password_changed_at = COALESCE(
        $2,
        password_changed_at
    ),
    email = COALESCE($3, email),
    is_email_verified = COALESCE(
        $4,
        is_email_verified
    ),
    avatar = COALESCE($5, avatar),
    balance = COALESCE($6, balance),
    secret_code = COALESCE(
        $7,
        secret_code
    ),
    is_used = COALESCE($8, is_used)
WHERE
    username = $9 RETURNING username, hashed_password, avatar, email, is_email_verified, password_changed_at, balance, address, file_path, secret_code, is_used, created_at, expired_at
`

type UpdateUserParams struct {
	HashedPassword    sql.NullString `json:"hashed_password"`
	PasswordChangedAt sql.NullTime   `json:"password_changed_at"`
	Email             sql.NullString `json:"email"`
	IsEmailVerified   sql.NullBool   `json:"is_email_verified"`
	Avatar            sql.NullString `json:"avatar"`
	Balance           sql.NullInt64  `json:"balance"`
	SecretCode        sql.NullString `json:"secret_code"`
	IsUsed            sql.NullBool   `json:"is_used"`
	Username          string         `json:"username"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (Users, error) {
	row := q.db.QueryRowContext(ctx, updateUser,
		arg.HashedPassword,
		arg.PasswordChangedAt,
		arg.Email,
		arg.IsEmailVerified,
		arg.Avatar,
		arg.Balance,
		arg.SecretCode,
		arg.IsUsed,
		arg.Username,
	)
	var i Users
	err := row.Scan(
		&i.Username,
		&i.HashedPassword,
		&i.Avatar,
		&i.Email,
		&i.IsEmailVerified,
		&i.PasswordChangedAt,
		&i.Balance,
		&i.Address,
		&i.FilePath,
		&i.SecretCode,
		&i.IsUsed,
		&i.CreatedAt,
		&i.ExpiredAt,
	)
	return i, err
}
