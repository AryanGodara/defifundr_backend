// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: waitlist.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countSearchWaitlist = `-- name: CountSearchWaitlist :one
SELECT COUNT(*)
FROM waitlist
WHERE 
  (
    email ILIKE '%' || $1 || '%' OR
    full_name ILIKE '%' || $1 || '%'
  )
`

// Counts the number of waitlist entries matching a search query
func (q *Queries) CountSearchWaitlist(ctx context.Context, dollar_1 pgtype.Text) (int64, error) {
	row := q.db.QueryRow(ctx, countSearchWaitlist, dollar_1)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countWaitlistEntries = `-- name: CountWaitlistEntries :one
SELECT COUNT(*) FROM waitlist
WHERE 
  ($1::text IS NULL OR status = $1) AND
  ($2::text IS NULL OR referral_source = $2)
`

type CountWaitlistEntriesParams struct {
	ID string `json:"id"`
	Column2 string `json:"column_2"`
}

// Counts the total number of waitlist entries matching filters
func (q *Queries) CountWaitlistEntries(ctx context.Context, arg CountWaitlistEntriesParams) (int64, error) {
	row := q.db.QueryRow(ctx, countWaitlistEntries, arg.ID, arg.Column2)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createWaitlistEntry = `-- name: CreateWaitlistEntry :one
INSERT INTO waitlist (
  id,
  email,
  full_name,
  referral_code,
  referral_source,
  status,
  signup_date,
  invited_date,
  registered_date,
  metadata,
  created_at,
  updated_at
) VALUES (
  COALESCE($1, uuid_generate_v4()),
  $2,
  $3,
  $4,
  $5,
  COALESCE($6, 'waiting'),
  COALESCE($7, now()),
  $8,
  $9,
  $10,
  COALESCE($11, now()),
  COALESCE($12, now())
) RETURNING id, email, full_name, referral_code, referral_source, status, signup_date, invited_date, registered_date, metadata, created_at, updated_at
`

type CreateWaitlistEntryParams struct {
	ID        interface{}        `json:"id"`
	Email          string             `json:"email"`
	FullName       pgtype.Text        `json:"full_name"`
	ReferralCode   string             `json:"referral_code"`
	ReferralSource pgtype.Text        `json:"referral_source"`
	Status        interface{}        `json:"status"`
	SignupDate     interface{}        `json:"signup_date"`
	InvitedDate    pgtype.Timestamptz `json:"invited_date"`
	RegisteredDate pgtype.Timestamptz `json:"registered_date"`
	Metadata       []byte             `json:"metadata"`
	CreatedAt       interface{}        `json:"created_at"`
	UpdatedAt       interface{}        `json:"updated_at"`
}

// Creates a new waitlist entry and returns the created entry
func (q *Queries) CreateWaitlistEntry(ctx context.Context, arg CreateWaitlistEntryParams) (Waitlist, error) {
	row := q.db.QueryRow(ctx, createWaitlistEntry,
		arg.ID,
		arg.Email,
		arg.FullName,
		arg.ReferralCode,
		arg.ReferralSource,
		arg.Status,
		arg.SignupDate,
		arg.InvitedDate,
		arg.RegisteredDate,
		arg.Metadata,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Waitlist
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.FullName,
		&i.ReferralCode,
		&i.ReferralSource,
		&i.Status,
		&i.SignupDate,
		&i.InvitedDate,
		&i.RegisteredDate,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteWaitlistEntry = `-- name: DeleteWaitlistEntry :exec
DELETE FROM waitlist
WHERE id = $1
`

// Permanently deletes a waitlist entry
func (q *Queries) DeleteWaitlistEntry(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteWaitlistEntry, id)
	return err
}

const exportWaitlistEntries = `-- name: ExportWaitlistEntries :many
SELECT id, email, full_name, referral_code, referral_source, status, signup_date, invited_date, registered_date, metadata, created_at, updated_at
FROM waitlist
ORDER BY signup_date DESC
`

// Retrieves all waitlist entries for export
func (q *Queries) ExportWaitlistEntries(ctx context.Context) ([]Waitlist, error) {
	rows, err := q.db.Query(ctx, exportWaitlistEntries)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Waitlist{}
	for rows.Next() {
		var i Waitlist
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.FullName,
			&i.ReferralCode,
			&i.ReferralSource,
			&i.Status,
			&i.SignupDate,
			&i.InvitedDate,
			&i.RegisteredDate,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWaitlistEntryByEmail = `-- name: GetWaitlistEntryByEmail :one
SELECT id, email, full_name, referral_code, referral_source, status, signup_date, invited_date, registered_date, metadata, created_at, updated_at FROM waitlist
WHERE email = $1
LIMIT 1
`

// Retrieves a single waitlist entry by email address
func (q *Queries) GetWaitlistEntryByEmail(ctx context.Context, email string) (Waitlist, error) {
	row := q.db.QueryRow(ctx, getWaitlistEntryByEmail, email)
	var i Waitlist
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.FullName,
		&i.ReferralCode,
		&i.ReferralSource,
		&i.Status,
		&i.SignupDate,
		&i.InvitedDate,
		&i.RegisteredDate,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getWaitlistEntryByID = `-- name: GetWaitlistEntryByID :one
SELECT id, email, full_name, referral_code, referral_source, status, signup_date, invited_date, registered_date, metadata, created_at, updated_at FROM waitlist 
WHERE id = $1 OR id::text = $1 
LIMIT 1
`

// Retrieves a single waitlist entry by ID
func (q *Queries) GetWaitlistEntryByID(ctx context.Context, id uuid.UUID) (Waitlist, error) {
	row := q.db.QueryRow(ctx, getWaitlistEntryByID, id)
	var i Waitlist
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.FullName,
		&i.ReferralCode,
		&i.ReferralSource,
		&i.Status,
		&i.SignupDate,
		&i.InvitedDate,
		&i.RegisteredDate,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getWaitlistEntryByReferralCode = `-- name: GetWaitlistEntryByReferralCode :one
SELECT id, email, full_name, referral_code, referral_source, status, signup_date, invited_date, registered_date, metadata, created_at, updated_at FROM waitlist
WHERE referral_code = $1
LIMIT 1
`

// Retrieves a single waitlist entry by referral code
func (q *Queries) GetWaitlistEntryByReferralCode(ctx context.Context, referralCode string) (Waitlist, error) {
	row := q.db.QueryRow(ctx, getWaitlistEntryByReferralCode, referralCode)
	var i Waitlist
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.FullName,
		&i.ReferralCode,
		&i.ReferralSource,
		&i.Status,
		&i.SignupDate,
		&i.InvitedDate,
		&i.RegisteredDate,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getWaitlistPosition = `-- name: GetWaitlistPosition :one
SELECT COUNT(*) 
FROM waitlist AS w1
WHERE w1.status = 'waiting' AND w1.signup_date <= (
  SELECT w2.signup_date FROM waitlist AS w2 WHERE w2.id = $1
)
`

// Gets the position of an entry in the waitlist (by signup date)
func (q *Queries) GetWaitlistPosition(ctx context.Context, id uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, getWaitlistPosition, id)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getWaitlistStatsBySource = `-- name: GetWaitlistStatsBySource :many
SELECT 
  referral_source, 
  COUNT(*) as count
FROM waitlist
GROUP BY referral_source
ORDER BY count DESC
`

type GetWaitlistStatsBySourceRow struct {
	ReferralSource pgtype.Text `json:"referral_source"`
	Count          int64       `json:"count"`
}

// Gets waitlist statistics grouped by referral source
func (q *Queries) GetWaitlistStatsBySource(ctx context.Context) ([]GetWaitlistStatsBySourceRow, error) {
	rows, err := q.db.Query(ctx, getWaitlistStatsBySource)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetWaitlistStatsBySourceRow{}
	for rows.Next() {
		var i GetWaitlistStatsBySourceRow
		if err := rows.Scan(&i.ReferralSource, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWaitlistStatsByStatus = `-- name: GetWaitlistStatsByStatus :many
SELECT 
  status, 
  COUNT(*) as count
FROM waitlist
GROUP BY status
ORDER BY count DESC
`

type GetWaitlistStatsByStatusRow struct {
	Status string `json:"status"`
	Count  int64  `json:"count"`
}

// Gets waitlist statistics grouped by status
func (q *Queries) GetWaitlistStatsByStatus(ctx context.Context) ([]GetWaitlistStatsByStatusRow, error) {
	rows, err := q.db.Query(ctx, getWaitlistStatsByStatus)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetWaitlistStatsByStatusRow{}
	for rows.Next() {
		var i GetWaitlistStatsByStatusRow
		if err := rows.Scan(&i.Status, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWaitlistEntries = `-- name: ListWaitlistEntries :many
SELECT id, email, full_name, referral_code, referral_source, status, signup_date, invited_date, registered_date, metadata, created_at, updated_at
FROM waitlist
WHERE 
  ($1::text IS NULL OR status = $1) AND
  ($2::text IS NULL OR referral_source = $2)
ORDER BY 
  CASE WHEN $5::text = 'signup_date_asc' THEN signup_date END ASC,
  CASE WHEN $5::text = 'signup_date_desc' OR $5::text IS NULL THEN signup_date END DESC
LIMIT $3
OFFSET $4
`

type ListWaitlistEntriesParams struct {
	ID string `json:"id"`
	Column2 string `json:"column_2"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
	Column5 string `json:"column_5"`
}

// Lists waitlist entries with pagination and filtering support
func (q *Queries) ListWaitlistEntries(ctx context.Context, arg ListWaitlistEntriesParams) ([]Waitlist, error) {
	rows, err := q.db.Query(ctx, listWaitlistEntries,
		arg.ID,
		arg.Column2,
		arg.Limit,
		arg.Offset,
		arg.Column5,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Waitlist{}
	for rows.Next() {
		var i Waitlist
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.FullName,
			&i.ReferralCode,
			&i.ReferralSource,
			&i.Status,
			&i.SignupDate,
			&i.InvitedDate,
			&i.RegisteredDate,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchWaitlist = `-- name: SearchWaitlist :many
SELECT id, email, full_name, referral_code, referral_source, status, signup_date, invited_date, registered_date, metadata, created_at, updated_at
FROM waitlist
WHERE 
  (
    email ILIKE '%' || $1 || '%' OR
    full_name ILIKE '%' || $1 || '%'
  )
ORDER BY signup_date DESC
LIMIT $2
OFFSET $3
`

type SearchWaitlistParams struct {
	ID pgtype.Text `json:"id"`
	Limit   int32       `json:"limit"`
	Offset  int32       `json:"offset"`
}

// Searches for waitlist entries by email or name with pagination
func (q *Queries) SearchWaitlist(ctx context.Context, arg SearchWaitlistParams) ([]Waitlist, error) {
	rows, err := q.db.Query(ctx, searchWaitlist, arg.ID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Waitlist{}
	for rows.Next() {
		var i Waitlist
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.FullName,
			&i.ReferralCode,
			&i.ReferralSource,
			&i.Status,
			&i.SignupDate,
			&i.InvitedDate,
			&i.RegisteredDate,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateWaitlistEntryStatus = `-- name: UpdateWaitlistEntryStatus :exec
UPDATE waitlist
SET
  status = $2,
  invited_date = CASE WHEN $2 = 'invited' AND invited_date IS NULL THEN now() ELSE invited_date END,
  registered_date = CASE WHEN $2 = 'registered' AND registered_date IS NULL THEN now() ELSE registered_date END,
  updated_at = now()
WHERE id = $1
`

type UpdateWaitlistEntryStatusParams struct {
	ID     uuid.UUID `json:"id"`
	Status string    `json:"status"`
}

// Updates the status of a waitlist entry
func (q *Queries) UpdateWaitlistEntryStatus(ctx context.Context, arg UpdateWaitlistEntryStatusParams) error {
	_, err := q.db.Exec(ctx, updateWaitlistEntryStatus, arg.ID, arg.Status)
	return err
}
